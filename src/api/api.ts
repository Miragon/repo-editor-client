/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * version of an artifact, contains the file and information about deployments
 * @export
 * @interface ArtifactMilestoneTO
 */
export interface ArtifactMilestoneTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof ArtifactMilestoneTO
     */
    milestone: number;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    file: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    saveType: ArtifactMilestoneTOSaveTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    updatedDate: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    artifactId: string;
    /**
     * 
     * @type {boolean}
     * @memberof ArtifactMilestoneTO
     */
    latestMilestone: boolean;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    repositoryId: string;
    /**
     * 
     * @type {Array<DeploymentTO>}
     * @memberof ArtifactMilestoneTO
     */
    deployments: Array<DeploymentTO>;
}

/**
    * @export
    * @enum {string}
    */
export enum ArtifactMilestoneTOSaveTypeEnum {
    Milestone = 'MILESTONE',
    Autosave = 'AUTOSAVE'
}

/**
 * Client created Object for updating accessible properties of a version
 * @export
 * @interface ArtifactMilestoneUpdateTO
 */
export interface ArtifactMilestoneUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneUpdateTO
     */
    milestoneId?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneUpdateTO
     */
    file?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneUpdateTO
     */
    comment?: string;
}
/**
 * Client created object for uploading a version from the client
 * @export
 * @interface ArtifactMilestoneUploadTO
 */
export interface ArtifactMilestoneUploadTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneUploadTO
     */
    comment?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneUploadTO
     */
    file?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneUploadTO
     */
    saveType?: ArtifactMilestoneUploadTOSaveTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ArtifactMilestoneUploadTOSaveTypeEnum {
    Milestone = 'MILESTONE',
    Autosave = 'AUTOSAVE'
}

/**
 * Transports an svg image as preview for an artifact
 * @export
 * @interface ArtifactSVGUploadTO
 */
export interface ArtifactSVGUploadTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactSVGUploadTO
     */
    svgPreview: string;
}
/**
 * Containing metadata for an artifact
 * @export
 * @interface ArtifactTO
 */
export interface ArtifactTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    createdDate: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    updatedDate: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    svgPreview?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    fileType: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    lockedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    lockedUntil?: string;
}
/**
 * Specifies properties for supported file types
 * @export
 * @interface ArtifactTypeTO
 */
export interface ArtifactTypeTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    fileExtension: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    svgIcon: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    url: string;
}
/**
 * Client created object for updating accessible properties of an artifact
 * @export
 * @interface ArtifactUpdateTO
 */
export interface ArtifactUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    fileType?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    svgPreview?: string;
}
/**
 * Containing information about a user-repository relation
 * @export
 * @interface AssignmentTO
 */
export interface AssignmentTO {
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    role: AssignmentTORoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AssignmentTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * Containing information about the deployment of an artifact
 * @export
 * @interface DeploymentTO
 */
export interface DeploymentTO {
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    target: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    user: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    timestamp: string;
}
/**
 * Containing the specifications for connected apps
 * @export
 * @interface MenuItemTO
 */
export interface MenuItemTO {
    /**
     * 
     * @type {string}
     * @memberof MenuItemTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MenuItemTO
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof MenuItemTO
     */
    icon: string;
    /**
     * 
     * @type {number}
     * @memberof MenuItemTO
     */
    position?: number;
}
/**
 * Client created object for creating a new artifact
 * @export
 * @interface NewArtifactTO
 */
export interface NewArtifactTO {
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    fileType: string;
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    svgPreview?: string;
}
/**
 * Client created object containing the deployment target and artifact(-version) id(-s) for creating a new deployment
 * @export
 * @interface NewDeploymentTO
 */
export interface NewDeploymentTO {
    /**
     * 
     * @type {string}
     * @memberof NewDeploymentTO
     */
    artifactId: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeploymentTO
     */
    milestoneId: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeploymentTO
     */
    target: string;
}
/**
 * Client created object for creating a new repository
 * @export
 * @interface NewRepositoryTO
 */
export interface NewRepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof NewRepositoryTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewRepositoryTO
     */
    description: string;
}
/**
 * Client created object for creating a new team
 * @export
 * @interface NewTeamTO
 */
export interface NewTeamTO {
    /**
     * 
     * @type {string}
     * @memberof NewTeamTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewTeamTO
     */
    description: string;
}
/**
 * Containing information about a repository-team relation
 * @export
 * @interface RepoTeamAssignmentTO
 */
export interface RepoTeamAssignmentTO {
    /**
     * 
     * @type {string}
     * @memberof RepoTeamAssignmentTO
     */
    teamId: string;
    /**
     * 
     * @type {string}
     * @memberof RepoTeamAssignmentTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof RepoTeamAssignmentTO
     */
    role: RepoTeamAssignmentTORoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum RepoTeamAssignmentTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * Containing information about a repository
 * @export
 * @interface RepositoryTO
 */
export interface RepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof RepositoryTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryTO
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof RepositoryTO
     */
    existingArtifacts: number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryTO
     */
    assignedUsers: number;
    /**
     * 
     * @type {Array<ArtifactTO>}
     * @memberof RepositoryTO
     */
    sharedArtifacts: Array<ArtifactTO>;
}
/**
 * 
 * @export
 * @interface RepositoryUpdateTO
 */
export interface RepositoryUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof RepositoryUpdateTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryUpdateTO
     */
    description: string;
}
/**
 * 
 * @export
 * @interface ShareWithRepositoryTO
 */
export interface ShareWithRepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof ShareWithRepositoryTO
     */
    artifactId: string;
    /**
     * 
     * @type {string}
     * @memberof ShareWithRepositoryTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof ShareWithRepositoryTO
     */
    role: ShareWithRepositoryTORoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ShareWithRepositoryTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * Share-relation between an artifact an a team
 * @export
 * @interface ShareWithTeamTO
 */
export interface ShareWithTeamTO {
    /**
     * 
     * @type {string}
     * @memberof ShareWithTeamTO
     */
    artifactId: string;
    /**
     * 
     * @type {string}
     * @memberof ShareWithTeamTO
     */
    teamId: string;
    /**
     * 
     * @type {string}
     * @memberof ShareWithTeamTO
     */
    role: ShareWithTeamTORoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ShareWithTeamTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * 
 * @export
 * @interface SharedRepositoryTO
 */
export interface SharedRepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof SharedRepositoryTO
     */
    artifactId: string;
    /**
     * 
     * @type {string}
     * @memberof SharedRepositoryTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof SharedRepositoryTO
     */
    role: SharedRepositoryTORoleEnum;
    /**
     * 
     * @type {string}
     * @memberof SharedRepositoryTO
     */
    artifactName?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedRepositoryTO
     */
    repositoryName?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SharedRepositoryTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * Share-relation between an artifact an a team
 * @export
 * @interface SharedTeamTO
 */
export interface SharedTeamTO {
    /**
     * 
     * @type {string}
     * @memberof SharedTeamTO
     */
    artifactId: string;
    /**
     * 
     * @type {string}
     * @memberof SharedTeamTO
     */
    teamId: string;
    /**
     * 
     * @type {string}
     * @memberof SharedTeamTO
     */
    role: SharedTeamTORoleEnum;
    /**
     * 
     * @type {string}
     * @memberof SharedTeamTO
     */
    artifactName?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedTeamTO
     */
    teamName?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SharedTeamTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * Containing information about a user-team relation
 * @export
 * @interface TeamAssignmentTO
 */
export interface TeamAssignmentTO {
    /**
     * 
     * @type {string}
     * @memberof TeamAssignmentTO
     */
    teamId: string;
    /**
     * 
     * @type {string}
     * @memberof TeamAssignmentTO
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof TeamAssignmentTO
     */
    role: TeamAssignmentTORoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TeamAssignmentTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * Containing information about a team
 * @export
 * @interface TeamTO
 */
export interface TeamTO {
    /**
     * 
     * @type {string}
     * @memberof TeamTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TeamTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TeamTO
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof TeamTO
     */
    assignedUsers: number;
}
/**
 * Containing information about a team update
 * @export
 * @interface TeamUpdateTO
 */
export interface TeamUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof TeamUpdateTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TeamUpdateTO
     */
    description: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
}
/**
 * Containing all information about an user
 * @export
 * @interface UserInfoTO
 */
export interface UserInfoTO {
    /**
     * 
     * @type {string}
     * @memberof UserInfoTO
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoTO
     */
    id: string;
}
/**
 * Simplified user object only containing username
 * @export
 * @interface UserTO
 */
export interface UserTO {
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    username: string;
}
/**
 * 
 * @export
 * @interface UserUpdateTO
 */
export interface UserUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateTO
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateTO
     */
    username?: string;
}

/**
 * ArtifactApi - axios parameter creator
 * @export
 */
export const ArtifactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Copy file to other repository
         * @param {string} repositoryId 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyToRepository: async (repositoryId: string, artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('copyToRepository', 'repositoryId', repositoryId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('copyToRepository', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/copy/{repositoryId}/{artifactId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an artifact
         * @param {string} repositoryId 
         * @param {NewArtifactTO} newArtifactTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact: async (repositoryId: string, newArtifactTO: NewArtifactTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('createArtifact', 'repositoryId', repositoryId)
            // verify required parameter 'newArtifactTO' is not null or undefined
            assertParamExists('createArtifact', 'newArtifactTO', newArtifactTO)
            const localVarPath = `/api/artifact/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newArtifactTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete one Artifact and all of its versions
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deleteArtifact', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all available file types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFileTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get single artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifact', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all artifacts of the given repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsFromRepo: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getArtifactsFromRepo', 'repositoryId', repositoryId)
            const localVarPath = `/api/artifact/repository/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all artifacts of a specific type from a repository
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByRepoIdAndType: async (repositoryId: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getByRepoIdAndType', 'repositoryId', repositoryId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getByRepoIdAndType', 'type', type)
            const localVarPath = `/api/artifact/{repositoryId}/{type}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recent artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifact/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all starred artifacts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStarred: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifact/starred`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lock a Artifact for editing. After calling, the artifact is locked for 10 minutes for the active user. Call the endpoint again, to reset the 10-minutes timer. Has to be called before \"getSingleVersion\" and \"createOrUpdateVersion\"
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('lockArtifact', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/{artifactId}/lock`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search artifacts by title.
         * @param {string} typedTitle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifacts: async (typedTitle: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typedTitle' is not null or undefined
            assertParamExists('searchArtifacts', 'typedTitle', typedTitle)
            const localVarPath = `/api/artifact/search/{typedTitle}`
                .replace(`{${"typedTitle"}}`, encodeURIComponent(String(typedTitle)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inverts the star-status (favorite-status) of an artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStarred: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('setStarred', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/starred/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlock a artifact after editing is finished
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('unlockArtifact', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/{artifactId}/unlock`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an artifact
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifact: async (artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updateArtifact', 'artifactId', artifactId)
            // verify required parameter 'artifactUpdateTO' is not null or undefined
            assertParamExists('updateArtifact', 'artifactUpdateTO', artifactUpdateTO)
            const localVarPath = `/api/artifact/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifactUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the preview svg of an artifact
         * @param {string} artifactId 
         * @param {ArtifactSVGUploadTO} artifactSVGUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreviewSVG: async (artifactId: string, artifactSVGUploadTO: ArtifactSVGUploadTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updatePreviewSVG', 'artifactId', artifactId)
            // verify required parameter 'artifactSVGUploadTO' is not null or undefined
            assertParamExists('updatePreviewSVG', 'artifactSVGUploadTO', artifactSVGUploadTO)
            const localVarPath = `/api/artifact/previewSVG/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifactSVGUploadTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactApi - functional programming interface
 * @export
 */
export const ArtifactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtifactApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Copy file to other repository
         * @param {string} repositoryId 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyToRepository(repositoryId: string, artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyToRepository(repositoryId, artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an artifact
         * @param {string} repositoryId 
         * @param {NewArtifactTO} newArtifactTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArtifact(repositoryId: string, newArtifactTO: NewArtifactTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArtifact(repositoryId, newArtifactTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete one Artifact and all of its versions
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifact(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all available file types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFileTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTypeTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFileTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get single artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifact(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all artifacts of the given repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactsFromRepo(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactsFromRepo(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all artifacts of a specific type from a repository
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByRepoIdAndType(repositoryId: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByRepoIdAndType(repositoryId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get recent artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecent(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all starred artifacts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStarred(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStarred(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lock a Artifact for editing. After calling, the artifact is locked for 10 minutes for the active user. Call the endpoint again, to reset the 10-minutes timer. Has to be called before \"getSingleVersion\" and \"createOrUpdateVersion\"
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockArtifact(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search artifacts by title.
         * @param {string} typedTitle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchArtifacts(typedTitle: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchArtifacts(typedTitle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inverts the star-status (favorite-status) of an artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setStarred(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setStarred(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlock a artifact after editing is finished
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockArtifact(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an artifact
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtifact(artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArtifact(artifactId, artifactUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the preview svg of an artifact
         * @param {string} artifactId 
         * @param {ArtifactSVGUploadTO} artifactSVGUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePreviewSVG(artifactId: string, artifactSVGUploadTO: ArtifactSVGUploadTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePreviewSVG(artifactId, artifactSVGUploadTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtifactApi - factory interface
 * @export
 */
export const ArtifactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtifactApiFp(configuration)
    return {
        /**
         * 
         * @summary Copy file to other repository
         * @param {string} repositoryId 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyToRepository(repositoryId: string, artifactId: string, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.copyToRepository(repositoryId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an artifact
         * @param {string} repositoryId 
         * @param {NewArtifactTO} newArtifactTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(repositoryId: string, newArtifactTO: NewArtifactTO, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.createArtifact(repositoryId, newArtifactTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete one Artifact and all of its versions
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all available file types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFileTypes(options?: any): AxiosPromise<Array<ArtifactTypeTO>> {
            return localVarFp.getAllFileTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get single artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifact(artifactId: string, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.getArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all artifacts of the given repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsFromRepo(repositoryId: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getArtifactsFromRepo(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all artifacts of a specific type from a repository
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByRepoIdAndType(repositoryId: string, type: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getByRepoIdAndType(repositoryId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recent artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent(options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getRecent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all starred artifacts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStarred(options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getStarred(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lock a Artifact for editing. After calling, the artifact is locked for 10 minutes for the active user. Call the endpoint again, to reset the 10-minutes timer. Has to be called before \"getSingleVersion\" and \"createOrUpdateVersion\"
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockArtifact(artifactId: string, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.lockArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search artifacts by title.
         * @param {string} typedTitle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifacts(typedTitle: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.searchArtifacts(typedTitle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inverts the star-status (favorite-status) of an artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStarred(artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.setStarred(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlock a artifact after editing is finished
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockArtifact(artifactId: string, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.unlockArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an artifact
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifact(artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.updateArtifact(artifactId, artifactUpdateTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the preview svg of an artifact
         * @param {string} artifactId 
         * @param {ArtifactSVGUploadTO} artifactSVGUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreviewSVG(artifactId: string, artifactSVGUploadTO: ArtifactSVGUploadTO, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.updatePreviewSVG(artifactId, artifactSVGUploadTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactApi - object-oriented interface
 * @export
 * @class ArtifactApi
 * @extends {BaseAPI}
 */
export class ArtifactApi extends BaseAPI {
    /**
     * 
     * @summary Copy file to other repository
     * @param {string} repositoryId 
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public copyToRepository(repositoryId: string, artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).copyToRepository(repositoryId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an artifact
     * @param {string} repositoryId 
     * @param {NewArtifactTO} newArtifactTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public createArtifact(repositoryId: string, newArtifactTO: NewArtifactTO, options?: any) {
        return ArtifactApiFp(this.configuration).createArtifact(repositoryId, newArtifactTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete one Artifact and all of its versions
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public deleteArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).deleteArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all available file types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getAllFileTypes(options?: any) {
        return ArtifactApiFp(this.configuration).getAllFileTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get single artifact
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).getArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all artifacts of the given repository
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getArtifactsFromRepo(repositoryId: string, options?: any) {
        return ArtifactApiFp(this.configuration).getArtifactsFromRepo(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all artifacts of a specific type from a repository
     * @param {string} repositoryId 
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getByRepoIdAndType(repositoryId: string, type: string, options?: any) {
        return ArtifactApiFp(this.configuration).getByRepoIdAndType(repositoryId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recent artifacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getRecent(options?: any) {
        return ArtifactApiFp(this.configuration).getRecent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all starred artifacts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getStarred(options?: any) {
        return ArtifactApiFp(this.configuration).getStarred(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lock a Artifact for editing. After calling, the artifact is locked for 10 minutes for the active user. Call the endpoint again, to reset the 10-minutes timer. Has to be called before \"getSingleVersion\" and \"createOrUpdateVersion\"
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public lockArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).lockArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search artifacts by title.
     * @param {string} typedTitle 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public searchArtifacts(typedTitle: string, options?: any) {
        return ArtifactApiFp(this.configuration).searchArtifacts(typedTitle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inverts the star-status (favorite-status) of an artifact
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public setStarred(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).setStarred(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlock a artifact after editing is finished
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public unlockArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).unlockArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an artifact
     * @param {string} artifactId 
     * @param {ArtifactUpdateTO} artifactUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public updateArtifact(artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any) {
        return ArtifactApiFp(this.configuration).updateArtifact(artifactId, artifactUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the preview svg of an artifact
     * @param {string} artifactId 
     * @param {ArtifactSVGUploadTO} artifactSVGUploadTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public updatePreviewSVG(artifactId: string, artifactSVGUploadTO: ArtifactSVGUploadTO, options?: any) {
        return ArtifactApiFp(this.configuration).updatePreviewSVG(artifactId, artifactSVGUploadTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deploy artifact milestone
         * @param {NewDeploymentTO} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployMilestone: async (newDeploymentTO: NewDeploymentTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newDeploymentTO' is not null or undefined
            assertParamExists('deployMilestone', 'newDeploymentTO', newDeploymentTO)
            const localVarPath = `/api/deploy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newDeploymentTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deploy multiple milestones
         * @param {Array<NewDeploymentTO>} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployMultipleMilestones: async (newDeploymentTO: Array<NewDeploymentTO>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newDeploymentTO' is not null or undefined
            assertParamExists('deployMultipleMilestones', 'newDeploymentTO', newDeploymentTO)
            const localVarPath = `/api/deploy/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newDeploymentTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all available deployment targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDeploymentTargets: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/deploy/target`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deploy artifact milestone
         * @param {NewDeploymentTO} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployMilestone(newDeploymentTO: NewDeploymentTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployMilestone(newDeploymentTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deploy multiple milestones
         * @param {Array<NewDeploymentTO>} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployMultipleMilestones(newDeploymentTO: Array<NewDeploymentTO>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactMilestoneTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployMultipleMilestones(newDeploymentTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all available deployment targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDeploymentTargets(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDeploymentTargets(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentApiFp(configuration)
    return {
        /**
         * 
         * @summary Deploy artifact milestone
         * @param {NewDeploymentTO} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployMilestone(newDeploymentTO: NewDeploymentTO, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return localVarFp.deployMilestone(newDeploymentTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deploy multiple milestones
         * @param {Array<NewDeploymentTO>} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployMultipleMilestones(newDeploymentTO: Array<NewDeploymentTO>, options?: any): AxiosPromise<Array<ArtifactMilestoneTO>> {
            return localVarFp.deployMultipleMilestones(newDeploymentTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all available deployment targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDeploymentTargets(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getAllDeploymentTargets(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * 
     * @summary Deploy artifact milestone
     * @param {NewDeploymentTO} newDeploymentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public deployMilestone(newDeploymentTO: NewDeploymentTO, options?: any) {
        return DeploymentApiFp(this.configuration).deployMilestone(newDeploymentTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deploy multiple milestones
     * @param {Array<NewDeploymentTO>} newDeploymentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public deployMultipleMilestones(newDeploymentTO: Array<NewDeploymentTO>, options?: any) {
        return DeploymentApiFp(this.configuration).deployMultipleMilestones(newDeploymentTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all available deployment targets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getAllDeploymentTargets(options?: any) {
        return DeploymentApiFp(this.configuration).getAllDeploymentTargets(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MenuApi - axios parameter creator
 * @export
 */
export const MenuApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all menu items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMenuItems: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/menu`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MenuApi - functional programming interface
 * @export
 */
export const MenuApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MenuApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all menu items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMenuItems(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MenuItemTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMenuItems(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MenuApi - factory interface
 * @export
 */
export const MenuApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MenuApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all menu items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMenuItems(options?: any): AxiosPromise<Array<MenuItemTO>> {
            return localVarFp.getAllMenuItems(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MenuApi - object-oriented interface
 * @export
 * @class MenuApi
 * @extends {BaseAPI}
 */
export class MenuApi extends BaseAPI {
    /**
     * 
     * @summary Get all menu items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public getAllMenuItems(options?: any) {
        return MenuApiFp(this.configuration).getAllMenuItems(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MilestoneApi - axios parameter creator
 * @export
 */
export const MilestoneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {string} artifactId 
         * @param {ArtifactMilestoneUploadTO} artifactMilestoneUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMilestone: async (artifactId: string, artifactMilestoneUploadTO: ArtifactMilestoneUploadTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('createMilestone', 'artifactId', artifactId)
            // verify required parameter 'artifactMilestoneUploadTO' is not null or undefined
            assertParamExists('createMilestone', 'artifactMilestoneUploadTO', artifactMilestoneUploadTO)
            const localVarPath = `/api/milestone/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifactMilestoneUploadTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a specific milestone
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMilestone: async (artifactId: string, milestoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('downloadMilestone', 'artifactId', artifactId)
            // verify required parameter 'milestoneId' is not null or undefined
            assertParamExists('downloadMilestone', 'milestoneId', milestoneId)
            const localVarPath = `/api/milestone/{artifactId}/{milestoneId}/download`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"milestoneId"}}`, encodeURIComponent(String(milestoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all milestones of the artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMilestones: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getAllMilestones', 'artifactId', artifactId)
            const localVarPath = `/api/milestone/{artifactId}/milestone`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest milestone of the requested milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {number} milestone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByMilestoneNumber: async (artifactId: string, milestone: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getByMilestoneNumber', 'artifactId', artifactId)
            // verify required parameter 'milestone' is not null or undefined
            assertParamExists('getByMilestoneNumber', 'milestone', milestone)
            const localVarPath = `/api/milestone/{artifactId}/milestoneNumber/{milestone}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"milestone"}}`, encodeURIComponent(String(milestone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the latest milestone of the requested artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestMilestone: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getLatestMilestone', 'artifactId', artifactId)
            const localVarPath = `/api/milestone/{artifactId}/milestone/latest`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMilestone: async (artifactId: string, milestoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getMilestone', 'artifactId', artifactId)
            // verify required parameter 'milestoneId' is not null or undefined
            assertParamExists('getMilestone', 'milestoneId', milestoneId)
            const localVarPath = `/api/milestone/{artifactId}/milestone/{milestoneId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"milestoneId"}}`, encodeURIComponent(String(milestoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {ArtifactMilestoneUpdateTO} artifactMilestoneUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMilestone: async (artifactMilestoneUpdateTO: ArtifactMilestoneUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactMilestoneUpdateTO' is not null or undefined
            assertParamExists('updateMilestone', 'artifactMilestoneUpdateTO', artifactMilestoneUpdateTO)
            const localVarPath = `/api/milestone/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifactMilestoneUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MilestoneApi - functional programming interface
 * @export
 */
export const MilestoneApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MilestoneApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {string} artifactId 
         * @param {ArtifactMilestoneUploadTO} artifactMilestoneUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMilestone(artifactId: string, artifactMilestoneUploadTO: ArtifactMilestoneUploadTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMilestone(artifactId, artifactMilestoneUploadTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download a specific milestone
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadMilestone(artifactId: string, milestoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadMilestone(artifactId, milestoneId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all milestones of the artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMilestones(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactMilestoneTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMilestones(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the latest milestone of the requested milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {number} milestone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByMilestoneNumber(artifactId: string, milestone: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByMilestoneNumber(artifactId, milestone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the latest milestone of the requested artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestMilestone(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestMilestone(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMilestone(artifactId: string, milestoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMilestone(artifactId, milestoneId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {ArtifactMilestoneUpdateTO} artifactMilestoneUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMilestone(artifactMilestoneUpdateTO: ArtifactMilestoneUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMilestone(artifactMilestoneUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MilestoneApi - factory interface
 * @export
 */
export const MilestoneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MilestoneApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {string} artifactId 
         * @param {ArtifactMilestoneUploadTO} artifactMilestoneUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMilestone(artifactId: string, artifactMilestoneUploadTO: ArtifactMilestoneUploadTO, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return localVarFp.createMilestone(artifactId, artifactMilestoneUploadTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a specific milestone
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMilestone(artifactId: string, milestoneId: string, options?: any): AxiosPromise<any> {
            return localVarFp.downloadMilestone(artifactId, milestoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all milestones of the artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMilestones(artifactId: string, options?: any): AxiosPromise<Array<ArtifactMilestoneTO>> {
            return localVarFp.getAllMilestones(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest milestone of the requested milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {number} milestone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByMilestoneNumber(artifactId: string, milestone: number, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return localVarFp.getByMilestoneNumber(artifactId, milestone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the latest milestone of the requested artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestMilestone(artifactId: string, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return localVarFp.getLatestMilestone(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMilestone(artifactId: string, milestoneId: string, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return localVarFp.getMilestone(artifactId, milestoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {ArtifactMilestoneUpdateTO} artifactMilestoneUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMilestone(artifactMilestoneUpdateTO: ArtifactMilestoneUpdateTO, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return localVarFp.updateMilestone(artifactMilestoneUpdateTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MilestoneApi - object-oriented interface
 * @export
 * @class MilestoneApi
 * @extends {BaseAPI}
 */
export class MilestoneApi extends BaseAPI {
    /**
     * 
     * @summary Create a new milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
     * @param {string} artifactId 
     * @param {ArtifactMilestoneUploadTO} artifactMilestoneUploadTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public createMilestone(artifactId: string, artifactMilestoneUploadTO: ArtifactMilestoneUploadTO, options?: any) {
        return MilestoneApiFp(this.configuration).createMilestone(artifactId, artifactMilestoneUploadTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a specific milestone
     * @param {string} artifactId 
     * @param {string} milestoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public downloadMilestone(artifactId: string, milestoneId: string, options?: any) {
        return MilestoneApiFp(this.configuration).downloadMilestone(artifactId, milestoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all milestones of the artifact
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public getAllMilestones(artifactId: string, options?: any) {
        return MilestoneApiFp(this.configuration).getAllMilestones(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest milestone of the requested milestone, read-permission granted even if Artifact is locked
     * @param {string} artifactId 
     * @param {number} milestone 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public getByMilestoneNumber(artifactId: string, milestone: number, options?: any) {
        return MilestoneApiFp(this.configuration).getByMilestoneNumber(artifactId, milestone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the latest milestone of the requested artifact
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public getLatestMilestone(artifactId: string, options?: any) {
        return MilestoneApiFp(this.configuration).getLatestMilestone(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific milestone, read-permission granted even if Artifact is locked
     * @param {string} artifactId 
     * @param {string} milestoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public getMilestone(artifactId: string, milestoneId: string, options?: any) {
        return MilestoneApiFp(this.configuration).getMilestone(artifactId, milestoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
     * @param {ArtifactMilestoneUpdateTO} artifactMilestoneUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public updateMilestone(artifactMilestoneUpdateTO: ArtifactMilestoneUpdateTO, options?: any) {
        return MilestoneApiFp(this.configuration).updateMilestone(artifactMilestoneUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepoAssignmentApi - axios parameter creator
 * @export
 */
export const RepoAssignmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAssignment: async (assignmentTO: AssignmentTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'assignmentTO' is not null or undefined
            assertParamExists('createUserAssignment', 'assignmentTO', assignmentTO)
            const localVarPath = `/api/repoAssignment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignmentTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user assignment to repository
         * @param {string} repositoryId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAssignment: async (repositoryId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('deleteUserAssignment', 'repositoryId', repositoryId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserAssignment', 'userId', userId)
            const localVarPath = `/api/repoAssignment/{repositoryId}/{userId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users assigned to a repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssignedUsers: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getAllAssignedUsers', 'repositoryId', repositoryId)
            const localVarPath = `/api/repoAssignment/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAssignment: async (assignmentTO: AssignmentTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'assignmentTO' is not null or undefined
            assertParamExists('updateUserAssignment', 'assignmentTO', assignmentTO)
            const localVarPath = `/api/repoAssignment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignmentTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepoAssignmentApi - functional programming interface
 * @export
 */
export const RepoAssignmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepoAssignmentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserAssignment(assignmentTO: AssignmentTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAssignment(assignmentTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete user assignment to repository
         * @param {string} repositoryId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserAssignment(repositoryId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserAssignment(repositoryId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all users assigned to a repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAssignedUsers(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssignmentTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAssignedUsers(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserAssignment(assignmentTO: AssignmentTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserAssignment(assignmentTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepoAssignmentApi - factory interface
 * @export
 */
export const RepoAssignmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepoAssignmentApiFp(configuration)
    return {
        /**
         * 
         * @summary Create user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAssignment(assignmentTO: AssignmentTO, options?: any): AxiosPromise<AssignmentTO> {
            return localVarFp.createUserAssignment(assignmentTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user assignment to repository
         * @param {string} repositoryId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAssignment(repositoryId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserAssignment(repositoryId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users assigned to a repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssignedUsers(repositoryId: string, options?: any): AxiosPromise<Array<AssignmentTO>> {
            return localVarFp.getAllAssignedUsers(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAssignment(assignmentTO: AssignmentTO, options?: any): AxiosPromise<AssignmentTO> {
            return localVarFp.updateUserAssignment(assignmentTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepoAssignmentApi - object-oriented interface
 * @export
 * @class RepoAssignmentApi
 * @extends {BaseAPI}
 */
export class RepoAssignmentApi extends BaseAPI {
    /**
     * 
     * @summary Create user assignment to repository
     * @param {AssignmentTO} assignmentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoAssignmentApi
     */
    public createUserAssignment(assignmentTO: AssignmentTO, options?: any) {
        return RepoAssignmentApiFp(this.configuration).createUserAssignment(assignmentTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user assignment to repository
     * @param {string} repositoryId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoAssignmentApi
     */
    public deleteUserAssignment(repositoryId: string, userId: string, options?: any) {
        return RepoAssignmentApiFp(this.configuration).deleteUserAssignment(repositoryId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users assigned to a repository
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoAssignmentApi
     */
    public getAllAssignedUsers(repositoryId: string, options?: any) {
        return RepoAssignmentApiFp(this.configuration).getAllAssignedUsers(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user assignment to repository
     * @param {AssignmentTO} assignmentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoAssignmentApi
     */
    public updateUserAssignment(assignmentTO: AssignmentTO, options?: any) {
        return RepoAssignmentApiFp(this.configuration).updateUserAssignment(assignmentTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepoTeamAssignmentApi - axios parameter creator
 * @export
 */
export const RepoTeamAssignmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an assignment between team and repository
         * @param {RepoTeamAssignmentTO} repoTeamAssignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepoTeamAssignment: async (repoTeamAssignmentTO: RepoTeamAssignmentTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoTeamAssignmentTO' is not null or undefined
            assertParamExists('createRepoTeamAssignment', 'repoTeamAssignmentTO', repoTeamAssignmentTO)
            const localVarPath = `/api/team/repoTeamAssignemnt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoTeamAssignmentTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an assignment between team and repository
         * @param {string} teamId 
         * @param {string} repoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepoTeamAssignment: async (teamId: string, repoId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('deleteRepoTeamAssignment', 'teamId', teamId)
            // verify required parameter 'repoId' is not null or undefined
            assertParamExists('deleteRepoTeamAssignment', 'repoId', repoId)
            const localVarPath = `/api/team/repoTeamAssignemnt/delete/{teamId}/{repoId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"repoId"}}`, encodeURIComponent(String(repoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an assignment between team and repository
         * @param {RepoTeamAssignmentTO} repoTeamAssignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepoTeamAssignment: async (repoTeamAssignmentTO: RepoTeamAssignmentTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repoTeamAssignmentTO' is not null or undefined
            assertParamExists('updateRepoTeamAssignment', 'repoTeamAssignmentTO', repoTeamAssignmentTO)
            const localVarPath = `/api/team/repoTeamAssignemnt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repoTeamAssignmentTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepoTeamAssignmentApi - functional programming interface
 * @export
 */
export const RepoTeamAssignmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepoTeamAssignmentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an assignment between team and repository
         * @param {RepoTeamAssignmentTO} repoTeamAssignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepoTeamAssignment(repoTeamAssignmentTO: RepoTeamAssignmentTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepoTeamAssignmentTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepoTeamAssignment(repoTeamAssignmentTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an assignment between team and repository
         * @param {string} teamId 
         * @param {string} repoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepoTeamAssignment(teamId: string, repoId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepoTeamAssignment(teamId, repoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an assignment between team and repository
         * @param {RepoTeamAssignmentTO} repoTeamAssignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepoTeamAssignment(repoTeamAssignmentTO: RepoTeamAssignmentTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepoTeamAssignmentTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepoTeamAssignment(repoTeamAssignmentTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepoTeamAssignmentApi - factory interface
 * @export
 */
export const RepoTeamAssignmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepoTeamAssignmentApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an assignment between team and repository
         * @param {RepoTeamAssignmentTO} repoTeamAssignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepoTeamAssignment(repoTeamAssignmentTO: RepoTeamAssignmentTO, options?: any): AxiosPromise<RepoTeamAssignmentTO> {
            return localVarFp.createRepoTeamAssignment(repoTeamAssignmentTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an assignment between team and repository
         * @param {string} teamId 
         * @param {string} repoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepoTeamAssignment(teamId: string, repoId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRepoTeamAssignment(teamId, repoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an assignment between team and repository
         * @param {RepoTeamAssignmentTO} repoTeamAssignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepoTeamAssignment(repoTeamAssignmentTO: RepoTeamAssignmentTO, options?: any): AxiosPromise<RepoTeamAssignmentTO> {
            return localVarFp.updateRepoTeamAssignment(repoTeamAssignmentTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepoTeamAssignmentApi - object-oriented interface
 * @export
 * @class RepoTeamAssignmentApi
 * @extends {BaseAPI}
 */
export class RepoTeamAssignmentApi extends BaseAPI {
    /**
     * 
     * @summary Create an assignment between team and repository
     * @param {RepoTeamAssignmentTO} repoTeamAssignmentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoTeamAssignmentApi
     */
    public createRepoTeamAssignment(repoTeamAssignmentTO: RepoTeamAssignmentTO, options?: any) {
        return RepoTeamAssignmentApiFp(this.configuration).createRepoTeamAssignment(repoTeamAssignmentTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an assignment between team and repository
     * @param {string} teamId 
     * @param {string} repoId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoTeamAssignmentApi
     */
    public deleteRepoTeamAssignment(teamId: string, repoId: string, options?: any) {
        return RepoTeamAssignmentApiFp(this.configuration).deleteRepoTeamAssignment(teamId, repoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an assignment between team and repository
     * @param {RepoTeamAssignmentTO} repoTeamAssignmentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoTeamAssignmentApi
     */
    public updateRepoTeamAssignment(repoTeamAssignmentTO: RepoTeamAssignmentTO, options?: any) {
        return RepoTeamAssignmentApiFp(this.configuration).updateRepoTeamAssignment(repoTeamAssignmentTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepositoryApi - axios parameter creator
 * @export
 */
export const RepositoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewRepositoryTO} newRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepository: async (newRepositoryTO: NewRepositoryTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newRepositoryTO' is not null or undefined
            assertParamExists('createRepository', 'newRepositoryTO', newRepositoryTO)
            const localVarPath = `/api/repo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newRepositoryTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('deleteRepository', 'repositoryId', repositoryId)
            const localVarPath = `/api/repo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositories: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/repo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all repositories accessible by the provided team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositoriesForTeam: async (teamId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getAllRepositoriesForTeam', 'teamId', teamId)
            const localVarPath = `/api/repo/team/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all repositories that can be managed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManageableRepositories: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/repo/administration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRepository: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getSingleRepository', 'repositoryId', repositoryId)
            const localVarPath = `/api/repo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for repositories by name
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRepositories: async (typedName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typedName' is not null or undefined
            assertParamExists('searchRepositories', 'typedName', typedName)
            const localVarPath = `/api/repo/search/{typedName}`
                .replace(`{${"typedName"}}`, encodeURIComponent(String(typedName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Repository
         * @param {string} repositoryId 
         * @param {RepositoryUpdateTO} repositoryUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepository: async (repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('updateRepository', 'repositoryId', repositoryId)
            // verify required parameter 'repositoryUpdateTO' is not null or undefined
            assertParamExists('updateRepository', 'repositoryUpdateTO', repositoryUpdateTO)
            const localVarPath = `/api/repo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repositoryUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryApi - functional programming interface
 * @export
 */
export const RepositoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewRepositoryTO} newRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepository(newRepositoryTO: NewRepositoryTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepository(newRepositoryTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepository(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepository(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRepositories(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRepositories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all repositories accessible by the provided team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRepositoriesForTeam(teamId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRepositoriesForTeam(teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all repositories that can be managed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManageableRepositories(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManageableRepositories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleRepository(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleRepository(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for repositories by name
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchRepositories(typedName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRepositories(typedName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Repository
         * @param {string} repositoryId 
         * @param {RepositoryUpdateTO} repositoryUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepository(repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepository(repositoryId, repositoryUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoryApi - factory interface
 * @export
 */
export const RepositoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewRepositoryTO} newRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepository(newRepositoryTO: NewRepositoryTO, options?: any): AxiosPromise<RepositoryTO> {
            return localVarFp.createRepository(newRepositoryTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository(repositoryId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRepository(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositories(options?: any): AxiosPromise<Array<RepositoryTO>> {
            return localVarFp.getAllRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all repositories accessible by the provided team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositoriesForTeam(teamId: string, options?: any): AxiosPromise<Array<RepositoryTO>> {
            return localVarFp.getAllRepositoriesForTeam(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all repositories that can be managed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManageableRepositories(options?: any): AxiosPromise<Array<RepositoryTO>> {
            return localVarFp.getManageableRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRepository(repositoryId: string, options?: any): AxiosPromise<RepositoryTO> {
            return localVarFp.getSingleRepository(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for repositories by name
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRepositories(typedName: string, options?: any): AxiosPromise<Array<RepositoryTO>> {
            return localVarFp.searchRepositories(typedName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Repository
         * @param {string} repositoryId 
         * @param {RepositoryUpdateTO} repositoryUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepository(repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options?: any): AxiosPromise<RepositoryTO> {
            return localVarFp.updateRepository(repositoryId, repositoryUpdateTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoryApi - object-oriented interface
 * @export
 * @class RepositoryApi
 * @extends {BaseAPI}
 */
export class RepositoryApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Repository
     * @param {NewRepositoryTO} newRepositoryTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public createRepository(newRepositoryTO: NewRepositoryTO, options?: any) {
        return RepositoryApiFp(this.configuration).createRepository(newRepositoryTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Repository if you own it
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public deleteRepository(repositoryId: string, options?: any) {
        return RepositoryApiFp(this.configuration).deleteRepository(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all Repositories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getAllRepositories(options?: any) {
        return RepositoryApiFp(this.configuration).getAllRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all repositories accessible by the provided team
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getAllRepositoriesForTeam(teamId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getAllRepositoriesForTeam(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all repositories that can be managed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getManageableRepositories(options?: any) {
        return RepositoryApiFp(this.configuration).getManageableRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Repository by providing its ID
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getSingleRepository(repositoryId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getSingleRepository(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for repositories by name
     * @param {string} typedName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public searchRepositories(typedName: string, options?: any) {
        return RepositoryApiFp(this.configuration).searchRepositories(typedName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Repository
     * @param {string} repositoryId 
     * @param {RepositoryUpdateTO} repositoryUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public updateRepository(repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options?: any) {
        return RepositoryApiFp(this.configuration).updateRepository(repositoryId, repositoryUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShareApi - axios parameter creator
 * @export
 */
export const ShareApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all shared Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedArtifacts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/share/artifacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Artifacts shared with Repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifacts: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getSharedArtifacts', 'repositoryId', repositoryId)
            const localVarPath = `/api/share/repository/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all artifacts that are shared via diverse repositories and filter by artifactType
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifactsByType: async (type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getSharedArtifactsByType', 'type', type)
            const localVarPath = `/api/share/artifacts/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all repositories that can access a specific artifact (Admin permission required)
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedRepositories: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getSharedRepositories', 'artifactId', artifactId)
            const localVarPath = `/api/share/relations/repository/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all repositories that can access a specific artifact (Admin Permission required)
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedTeams: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getSharedTeams', 'artifactId', artifactId)
            const localVarPath = `/api/share/relations/team/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Artifacts shared with team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedWithTeamArtifacts: async (teamId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getSharedWithTeamArtifacts', 'teamId', teamId)
            const localVarPath = `/api/share/team/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Share an artifact with all members of another repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareWithRepository: async (shareWithRepositoryTO: ShareWithRepositoryTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareWithRepositoryTO' is not null or undefined
            assertParamExists('shareWithRepository', 'shareWithRepositoryTO', shareWithRepositoryTO)
            const localVarPath = `/api/share/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareWithRepositoryTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Share an artifact with all members of another team
         * @param {ShareWithTeamTO} shareWithTeamTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareWithTeam: async (shareWithTeamTO: ShareWithTeamTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareWithTeamTO' is not null or undefined
            assertParamExists('shareWithTeam', 'shareWithTeamTO', shareWithTeamTO)
            const localVarPath = `/api/share/team`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareWithTeamTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareArtifactWithRepository: async (artifactId: string, repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('unshareArtifactWithRepository', 'artifactId', artifactId)
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('unshareArtifactWithRepository', 'repositoryId', repositoryId)
            const localVarPath = `/api/share/repository/unshare/{artifactId}/{repositoryId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareArtifactWithTeam: async (artifactId: string, teamId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('unshareArtifactWithTeam', 'artifactId', artifactId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('unshareArtifactWithTeam', 'teamId', teamId)
            const localVarPath = `/api/share/team/unshare/{artifactId}/{teamId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the share-role of a relation with a repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareWithRepository: async (shareWithRepositoryTO: ShareWithRepositoryTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareWithRepositoryTO' is not null or undefined
            assertParamExists('updateShareWithRepository', 'shareWithRepositoryTO', shareWithRepositoryTO)
            const localVarPath = `/api/share/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareWithRepositoryTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the share-role of a relation with a team
         * @param {ShareWithTeamTO} shareWithTeamTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareWithTeam: async (shareWithTeamTO: ShareWithTeamTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareWithTeamTO' is not null or undefined
            assertParamExists('updateShareWithTeam', 'shareWithTeamTO', shareWithTeamTO)
            const localVarPath = `/api/share/team`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareWithTeamTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShareApi - functional programming interface
 * @export
 */
export const ShareApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShareApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all shared Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSharedArtifacts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSharedArtifacts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Artifacts shared with Repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedArtifacts(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedArtifacts(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all artifacts that are shared via diverse repositories and filter by artifactType
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedArtifactsByType(type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedArtifactsByType(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all repositories that can access a specific artifact (Admin permission required)
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedRepositories(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SharedRepositoryTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedRepositories(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all repositories that can access a specific artifact (Admin Permission required)
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedTeams(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SharedTeamTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedTeams(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Artifacts shared with team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedWithTeamArtifacts(teamId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedWithTeamArtifacts(teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Share an artifact with all members of another repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareWithRepositoryTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareWithRepository(shareWithRepositoryTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Share an artifact with all members of another team
         * @param {ShareWithTeamTO} shareWithTeamTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareWithTeam(shareWithTeamTO: ShareWithTeamTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareWithTeamTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareWithTeam(shareWithTeamTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unshareArtifactWithRepository(artifactId: string, repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unshareArtifactWithRepository(artifactId, repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unshareArtifactWithTeam(artifactId: string, teamId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unshareArtifactWithTeam(artifactId, teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the share-role of a relation with a repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareWithRepositoryTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShareWithRepository(shareWithRepositoryTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the share-role of a relation with a team
         * @param {ShareWithTeamTO} shareWithTeamTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShareWithTeam(shareWithTeamTO: ShareWithTeamTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareWithTeamTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShareWithTeam(shareWithTeamTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShareApi - factory interface
 * @export
 */
export const ShareApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShareApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all shared Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedArtifacts(options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getAllSharedArtifacts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Artifacts shared with Repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifacts(repositoryId: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getSharedArtifacts(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all artifacts that are shared via diverse repositories and filter by artifactType
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifactsByType(type: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getSharedArtifactsByType(type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all repositories that can access a specific artifact (Admin permission required)
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedRepositories(artifactId: string, options?: any): AxiosPromise<Array<SharedRepositoryTO>> {
            return localVarFp.getSharedRepositories(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all repositories that can access a specific artifact (Admin Permission required)
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedTeams(artifactId: string, options?: any): AxiosPromise<Array<SharedTeamTO>> {
            return localVarFp.getSharedTeams(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Artifacts shared with team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedWithTeamArtifacts(teamId: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getSharedWithTeamArtifacts(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Share an artifact with all members of another repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any): AxiosPromise<ShareWithRepositoryTO> {
            return localVarFp.shareWithRepository(shareWithRepositoryTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Share an artifact with all members of another team
         * @param {ShareWithTeamTO} shareWithTeamTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareWithTeam(shareWithTeamTO: ShareWithTeamTO, options?: any): AxiosPromise<ShareWithTeamTO> {
            return localVarFp.shareWithTeam(shareWithTeamTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareArtifactWithRepository(artifactId: string, repositoryId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unshareArtifactWithRepository(artifactId, repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareArtifactWithTeam(artifactId: string, teamId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unshareArtifactWithTeam(artifactId, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the share-role of a relation with a repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any): AxiosPromise<ShareWithRepositoryTO> {
            return localVarFp.updateShareWithRepository(shareWithRepositoryTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the share-role of a relation with a team
         * @param {ShareWithTeamTO} shareWithTeamTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareWithTeam(shareWithTeamTO: ShareWithTeamTO, options?: any): AxiosPromise<ShareWithTeamTO> {
            return localVarFp.updateShareWithTeam(shareWithTeamTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShareApi - object-oriented interface
 * @export
 * @class ShareApi
 * @extends {BaseAPI}
 */
export class ShareApi extends BaseAPI {
    /**
     * 
     * @summary Get all shared Artifacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getAllSharedArtifacts(options?: any) {
        return ShareApiFp(this.configuration).getAllSharedArtifacts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Artifacts shared with Repository
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedArtifacts(repositoryId: string, options?: any) {
        return ShareApiFp(this.configuration).getSharedArtifacts(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all artifacts that are shared via diverse repositories and filter by artifactType
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedArtifactsByType(type: string, options?: any) {
        return ShareApiFp(this.configuration).getSharedArtifactsByType(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all repositories that can access a specific artifact (Admin permission required)
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedRepositories(artifactId: string, options?: any) {
        return ShareApiFp(this.configuration).getSharedRepositories(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all repositories that can access a specific artifact (Admin Permission required)
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedTeams(artifactId: string, options?: any) {
        return ShareApiFp(this.configuration).getSharedTeams(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Artifacts shared with team
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedWithTeamArtifacts(teamId: string, options?: any) {
        return ShareApiFp(this.configuration).getSharedWithTeamArtifacts(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Share an artifact with all members of another repository
     * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public shareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any) {
        return ShareApiFp(this.configuration).shareWithRepository(shareWithRepositoryTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Share an artifact with all members of another team
     * @param {ShareWithTeamTO} shareWithTeamTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public shareWithTeam(shareWithTeamTO: ShareWithTeamTO, options?: any) {
        return ShareApiFp(this.configuration).shareWithTeam(shareWithTeamTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the sharing-relation to a specific repository
     * @param {string} artifactId 
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public unshareArtifactWithRepository(artifactId: string, repositoryId: string, options?: any) {
        return ShareApiFp(this.configuration).unshareArtifactWithRepository(artifactId, repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the sharing-relation to a specific repository
     * @param {string} artifactId 
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public unshareArtifactWithTeam(artifactId: string, teamId: string, options?: any) {
        return ShareApiFp(this.configuration).unshareArtifactWithTeam(artifactId, teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the share-role of a relation with a repository
     * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public updateShareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any) {
        return ShareApiFp(this.configuration).updateShareWithRepository(shareWithRepositoryTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the share-role of a relation with a team
     * @param {ShareWithTeamTO} shareWithTeamTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public updateShareWithTeam(shareWithTeamTO: ShareWithTeamTO, options?: any) {
        return ShareApiFp(this.configuration).updateShareWithTeam(shareWithTeamTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamApi - axios parameter creator
 * @export
 */
export const TeamApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Team
         * @param {NewTeamTO} newTeamTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam: async (newTeamTO: NewTeamTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newTeamTO' is not null or undefined
            assertParamExists('createTeam', 'newTeamTO', newTeamTO)
            const localVarPath = `/api/team`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newTeamTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam: async (teamId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('deleteTeam', 'teamId', teamId)
            const localVarPath = `/api/team/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all assigned Teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTeams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/team`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get multiple Teams by providing their Ids
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultipleTeams: async (requestBody: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('getMultipleTeams', 'requestBody', requestBody)
            const localVarPath = `/api/team/multiple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Team by providing its ID
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam: async (teamId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getTeam', 'teamId', teamId)
            const localVarPath = `/api/team/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for Teams by name
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTeams: async (typedName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typedName' is not null or undefined
            assertParamExists('searchTeams', 'typedName', typedName)
            const localVarPath = `/api/team/search/{typedName}`
                .replace(`{${"typedName"}}`, encodeURIComponent(String(typedName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Team
         * @param {string} teamId 
         * @param {TeamUpdateTO} teamUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam: async (teamId: string, teamUpdateTO: TeamUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('updateTeam', 'teamId', teamId)
            // verify required parameter 'teamUpdateTO' is not null or undefined
            assertParamExists('updateTeam', 'teamUpdateTO', teamUpdateTO)
            const localVarPath = `/api/team/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamApi - functional programming interface
 * @export
 */
export const TeamApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Team
         * @param {NewTeamTO} newTeamTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeam(newTeamTO: NewTeamTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeam(newTeamTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeam(teamId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeam(teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all assigned Teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTeams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTeams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get multiple Teams by providing their Ids
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMultipleTeams(requestBody: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMultipleTeams(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Team by providing its ID
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeam(teamId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeam(teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for Teams by name
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTeams(typedName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTeams(typedName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Team
         * @param {string} teamId 
         * @param {TeamUpdateTO} teamUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeam(teamId: string, teamUpdateTO: TeamUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeam(teamId, teamUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamApi - factory interface
 * @export
 */
export const TeamApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Team
         * @param {NewTeamTO} newTeamTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(newTeamTO: NewTeamTO, options?: any): AxiosPromise<TeamTO> {
            return localVarFp.createTeam(newTeamTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(teamId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTeam(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all assigned Teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTeams(options?: any): AxiosPromise<Array<TeamTO>> {
            return localVarFp.getAllTeams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get multiple Teams by providing their Ids
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultipleTeams(requestBody: Array<string>, options?: any): AxiosPromise<Array<TeamTO>> {
            return localVarFp.getMultipleTeams(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Team by providing its ID
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(teamId: string, options?: any): AxiosPromise<TeamTO> {
            return localVarFp.getTeam(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for Teams by name
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTeams(typedName: string, options?: any): AxiosPromise<Array<TeamTO>> {
            return localVarFp.searchTeams(typedName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Team
         * @param {string} teamId 
         * @param {TeamUpdateTO} teamUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(teamId: string, teamUpdateTO: TeamUpdateTO, options?: any): AxiosPromise<TeamTO> {
            return localVarFp.updateTeam(teamId, teamUpdateTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamApi - object-oriented interface
 * @export
 * @class TeamApi
 * @extends {BaseAPI}
 */
export class TeamApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Team
     * @param {NewTeamTO} newTeamTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public createTeam(newTeamTO: NewTeamTO, options?: any) {
        return TeamApiFp(this.configuration).createTeam(newTeamTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Team
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public deleteTeam(teamId: string, options?: any) {
        return TeamApiFp(this.configuration).deleteTeam(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all assigned Teams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getAllTeams(options?: any) {
        return TeamApiFp(this.configuration).getAllTeams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get multiple Teams by providing their Ids
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getMultipleTeams(requestBody: Array<string>, options?: any) {
        return TeamApiFp(this.configuration).getMultipleTeams(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Team by providing its ID
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public getTeam(teamId: string, options?: any) {
        return TeamApiFp(this.configuration).getTeam(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for Teams by name
     * @param {string} typedName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public searchTeams(typedName: string, options?: any) {
        return TeamApiFp(this.configuration).searchTeams(typedName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Team
     * @param {string} teamId 
     * @param {TeamUpdateTO} teamUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamApi
     */
    public updateTeam(teamId: string, teamUpdateTO: TeamUpdateTO, options?: any) {
        return TeamApiFp(this.configuration).updateTeam(teamId, teamUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamAssignmentApi - axios parameter creator
 * @export
 */
export const TeamAssignmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create user assignment to Team
         * @param {TeamAssignmentTO} teamAssignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeamAssignment: async (teamAssignmentTO: TeamAssignmentTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamAssignmentTO' is not null or undefined
            assertParamExists('createTeamAssignment', 'teamAssignmentTO', teamAssignmentTO)
            const localVarPath = `/api/teamAssignment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamAssignmentTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user assignment to team
         * @param {string} teamId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamUserAssignment: async (teamId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('deleteTeamUserAssignment', 'teamId', teamId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteTeamUserAssignment', 'userId', userId)
            const localVarPath = `/api/teamAssignment/{teamId}/{userId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users assigned to a team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTeamAssignedUsers: async (teamId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getAllTeamAssignedUsers', 'teamId', teamId)
            const localVarPath = `/api/teamAssignment/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user assignment to Team
         * @param {TeamAssignmentTO} teamAssignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamAssignment: async (teamAssignmentTO: TeamAssignmentTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamAssignmentTO' is not null or undefined
            assertParamExists('updateTeamAssignment', 'teamAssignmentTO', teamAssignmentTO)
            const localVarPath = `/api/teamAssignment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamAssignmentTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamAssignmentApi - functional programming interface
 * @export
 */
export const TeamAssignmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamAssignmentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create user assignment to Team
         * @param {TeamAssignmentTO} teamAssignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeamAssignment(teamAssignmentTO: TeamAssignmentTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamAssignmentTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeamAssignment(teamAssignmentTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete user assignment to team
         * @param {string} teamId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeamUserAssignment(teamId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeamUserAssignment(teamId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all users assigned to a team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTeamAssignedUsers(teamId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamAssignmentTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTeamAssignedUsers(teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user assignment to Team
         * @param {TeamAssignmentTO} teamAssignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeamAssignment(teamAssignmentTO: TeamAssignmentTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamAssignmentTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeamAssignment(teamAssignmentTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamAssignmentApi - factory interface
 * @export
 */
export const TeamAssignmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamAssignmentApiFp(configuration)
    return {
        /**
         * 
         * @summary Create user assignment to Team
         * @param {TeamAssignmentTO} teamAssignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeamAssignment(teamAssignmentTO: TeamAssignmentTO, options?: any): AxiosPromise<TeamAssignmentTO> {
            return localVarFp.createTeamAssignment(teamAssignmentTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user assignment to team
         * @param {string} teamId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamUserAssignment(teamId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTeamUserAssignment(teamId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users assigned to a team
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTeamAssignedUsers(teamId: string, options?: any): AxiosPromise<Array<TeamAssignmentTO>> {
            return localVarFp.getAllTeamAssignedUsers(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user assignment to Team
         * @param {TeamAssignmentTO} teamAssignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamAssignment(teamAssignmentTO: TeamAssignmentTO, options?: any): AxiosPromise<TeamAssignmentTO> {
            return localVarFp.updateTeamAssignment(teamAssignmentTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamAssignmentApi - object-oriented interface
 * @export
 * @class TeamAssignmentApi
 * @extends {BaseAPI}
 */
export class TeamAssignmentApi extends BaseAPI {
    /**
     * 
     * @summary Create user assignment to Team
     * @param {TeamAssignmentTO} teamAssignmentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAssignmentApi
     */
    public createTeamAssignment(teamAssignmentTO: TeamAssignmentTO, options?: any) {
        return TeamAssignmentApiFp(this.configuration).createTeamAssignment(teamAssignmentTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user assignment to team
     * @param {string} teamId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAssignmentApi
     */
    public deleteTeamUserAssignment(teamId: string, userId: string, options?: any) {
        return TeamAssignmentApiFp(this.configuration).deleteTeamUserAssignment(teamId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users assigned to a team
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAssignmentApi
     */
    public getAllTeamAssignedUsers(teamId: string, options?: any) {
        return TeamAssignmentApiFp(this.configuration).getAllTeamAssignedUsers(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user assignment to Team
     * @param {TeamAssignmentTO} teamAssignmentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAssignmentApi
     */
    public updateTeamAssignment(teamAssignmentTO: TeamAssignmentTO, options?: any) {
        return TeamAssignmentApiFp(this.configuration).updateTeamAssignment(teamAssignmentTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of users by providing their Ids
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultipleUsers: async (requestBody: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('getMultipleUsers', 'requestBody', requestBody)
            const localVarPath = `/api/user/multiple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the User that is currently sending requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/currentUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the namae of the user that is currently sending requests (name equals email address)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserName: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/registeredEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of users that matches the typed letters of a search
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: async (typedName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typedName' is not null or undefined
            assertParamExists('searchUsers', 'typedName', typedName)
            const localVarPath = `/api/user/search/{typedName}`
                .replace(`{${"typedName"}}`, encodeURIComponent(String(typedName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the user
         * @param {UserUpdateTO} userUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userUpdateTO: UserUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdateTO' is not null or undefined
            assertParamExists('updateUser', 'userUpdateTO', userUpdateTO)
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of users by providing their Ids
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMultipleUsers(requestBody: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfoTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMultipleUsers(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the User that is currently sending requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the namae of the user that is currently sending requests (name equals email address)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserName(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserName(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of users that matches the typed letters of a search
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers(typedName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfoTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsers(typedName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the user
         * @param {UserUpdateTO} userUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userUpdateTO: UserUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(options?: any): AxiosPromise<UserTO> {
            return localVarFp.createUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of users by providing their Ids
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultipleUsers(requestBody: Array<string>, options?: any): AxiosPromise<Array<UserInfoTO>> {
            return localVarFp.getMultipleUsers(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the User that is currently sending requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: any): AxiosPromise<UserInfoTO> {
            return localVarFp.getUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the namae of the user that is currently sending requests (name equals email address)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserName(options?: any): AxiosPromise<string> {
            return localVarFp.getUserName(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of users that matches the typed letters of a search
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(typedName: string, options?: any): AxiosPromise<Array<UserInfoTO>> {
            return localVarFp.searchUsers(typedName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the user
         * @param {UserUpdateTO} userUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userUpdateTO: UserUpdateTO, options?: any): AxiosPromise<User> {
            return localVarFp.updateUser(userUpdateTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Create a new User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(options?: any) {
        return UserApiFp(this.configuration).createUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of users by providing their Ids
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMultipleUsers(requestBody: Array<string>, options?: any) {
        return UserApiFp(this.configuration).getMultipleUsers(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the User that is currently sending requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserInfo(options?: any) {
        return UserApiFp(this.configuration).getUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the namae of the user that is currently sending requests (name equals email address)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserName(options?: any) {
        return UserApiFp(this.configuration).getUserName(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of users that matches the typed letters of a search
     * @param {string} typedName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public searchUsers(typedName: string, options?: any) {
        return UserApiFp(this.configuration).searchUsers(typedName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the user
     * @param {UserUpdateTO} userUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(userUpdateTO: UserUpdateTO, options?: any) {
        return UserApiFp(this.configuration).updateUser(userUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }
}


