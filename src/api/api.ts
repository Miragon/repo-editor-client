/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import {Configuration} from './configuration';
import globalAxios, {AxiosInstance, AxiosPromise} from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
    assertParamExists,
    createRequestFunction,
    DUMMY_BASE_URL,
    serializeDataIfNeeded,
    setApiKeyToObject,
    setBasicAuthToObject,
    setBearerAuthToObject,
    setOAuthToObject,
    setSearchParams,
    toPathString
} from './common';
// @ts-ignore
import {BASE_PATH, BaseAPI, COLLECTION_FORMATS, RequestArgs, RequiredError} from './base';

/**
 * 
 * @export
 * @interface ArtifactSVGUploadTO
 */
export interface ArtifactSVGUploadTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactSVGUploadTO
     */
    svgPreview: string;
}
/**
 * 
 * @export
 * @interface ArtifactTO
 */
export interface ArtifactTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    createdDate: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    updatedDate: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    svgPreview?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    fileType: string;
}
/**
 * 
 * @export
 * @interface ArtifactTypeTO
 */
export interface ArtifactTypeTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    fileExtension: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    svgIcon: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    url: string;
}
/**
 * 
 * @export
 * @interface ArtifactUpdateTO
 */
export interface ArtifactUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    fileType?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    svgPreview?: string;
}
/**
 * 
 * @export
 * @interface ArtifactVersionTO
 */
export interface ArtifactVersionTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionTO
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof ArtifactVersionTO
     */
    milestone: number;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionTO
     */
    file: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionTO
     */
    saveType: ArtifactVersionTOSaveTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionTO
     */
    updatedDate: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionTO
     */
    artifactId: string;
    /**
     * 
     * @type {boolean}
     * @memberof ArtifactVersionTO
     */
    latestVersion: boolean;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionTO
     */
    repositoryId: string;
    /**
     * 
     * @type {Array<DeploymentTO>}
     * @memberof ArtifactVersionTO
     */
    deployments: Array<DeploymentTO>;
}

/**
    * @export
    * @enum {string}
    */
export enum ArtifactVersionTOSaveTypeEnum {
    Milestone = 'MILESTONE',
    Autosave = 'AUTOSAVE'
}

/**
 * 
 * @export
 * @interface ArtifactVersionUpdateTO
 */
export interface ArtifactVersionUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionUpdateTO
     */
    versionId?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionUpdateTO
     */
    file?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionUpdateTO
     */
    versionComment?: string;
}
/**
 * 
 * @export
 * @interface ArtifactVersionUploadTO
 */
export interface ArtifactVersionUploadTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionUploadTO
     */
    versionComment?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionUploadTO
     */
    file?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionUploadTO
     */
    saveType?: ArtifactVersionUploadTOSaveTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ArtifactVersionUploadTOSaveTypeEnum {
    Milestone = 'MILESTONE',
    Autosave = 'AUTOSAVE'
}

/**
 * 
 * @export
 * @interface AssignmentTO
 */
export interface AssignmentTO {
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    role: AssignmentTORoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AssignmentTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * 
 * @export
 * @interface AssignmentUpdateTO
 */
export interface AssignmentUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof AssignmentUpdateTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentUpdateTO
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentUpdateTO
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentUpdateTO
     */
    role: AssignmentUpdateTORoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AssignmentUpdateTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * 
 * @export
 * @interface DeploymentTO
 */
export interface DeploymentTO {
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    target: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    user: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    timestamp: string;
}
/**
 * 
 * @export
 * @interface MenuItemTO
 */
export interface MenuItemTO {
    /**
     * 
     * @type {string}
     * @memberof MenuItemTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MenuItemTO
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof MenuItemTO
     */
    icon: string;
    /**
     * 
     * @type {number}
     * @memberof MenuItemTO
     */
    position?: number;
}
/**
 * 
 * @export
 * @interface NewArtifactTO
 */
export interface NewArtifactTO {
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    fileType: string;
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    svgPreview?: string;
}
/**
 * 
 * @export
 * @interface NewDeploymentTO
 */
export interface NewDeploymentTO {
    /**
     * 
     * @type {string}
     * @memberof NewDeploymentTO
     */
    target: string;
}
/**
 * 
 * @export
 * @interface NewRepositoryTO
 */
export interface NewRepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof NewRepositoryTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewRepositoryTO
     */
    description: string;
}
/**
 * 
 * @export
 * @interface RepositoryTO
 */
export interface RepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof RepositoryTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryTO
     */
    description: string;
    /**
     * 
     * @type {Array<ArtifactTO>}
     * @memberof RepositoryTO
     */
    sharedArtifacts?: Array<ArtifactTO>;
    /**
     * 
     * @type {number}
     * @memberof RepositoryTO
     */
    existingArtifacts: number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryTO
     */
    assignedUsers: number;
}
/**
 * 
 * @export
 * @interface RepositoryUpdateTO
 */
export interface RepositoryUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof RepositoryUpdateTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryUpdateTO
     */
    description: string;
}
/**
 * 
 * @export
 * @interface ShareWithRepositoryTO
 */
export interface ShareWithRepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof ShareWithRepositoryTO
     */
    artifactId: string;
    /**
     * 
     * @type {string}
     * @memberof ShareWithRepositoryTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof ShareWithRepositoryTO
     */
    role: ShareWithRepositoryTORoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ShareWithRepositoryTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * 
 * @export
 * @interface ShareWithTeamTO
 */
export interface ShareWithTeamTO {
    /**
     * 
     * @type {string}
     * @memberof ShareWithTeamTO
     */
    artifactId: string;
    /**
     * 
     * @type {string}
     * @memberof ShareWithTeamTO
     */
    teamId: string;
    /**
     * 
     * @type {string}
     * @memberof ShareWithTeamTO
     */
    role: ShareWithTeamTORoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ShareWithTeamTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface UserInfoTO
 */
export interface UserInfoTO {
    /**
     * 
     * @type {string}
     * @memberof UserInfoTO
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoTO
     */
    id: string;
}
/**
 * 
 * @export
 * @interface UserTO
 */
export interface UserTO {
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    userName: string;
}
/**
 * 
 * @export
 * @interface UserUpdateTO
 */
export interface UserUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateTO
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateTO
     */
    username?: string;
}

/**
 * ArtifactApi - axios parameter creator
 * @export
 */
export const ArtifactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} repositoryId 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyToRepository: async (repositoryId: string, artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('copyToRepository', 'repositoryId', repositoryId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('copyToRepository', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/copy/{repositoryId}/{artifactId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {NewArtifactTO} newArtifactTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact: async (repositoryId: string, newArtifactTO: NewArtifactTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('createArtifact', 'repositoryId', repositoryId)
            // verify required parameter 'newArtifactTO' is not null or undefined
            assertParamExists('createArtifact', 'newArtifactTO', newArtifactTO)
            const localVarPath = `/api/artifact/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newArtifactTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete one Artifact and all of its versions
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deleteArtifact', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFileTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifact', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsFromRepo: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getArtifactsFromRepo', 'repositoryId', repositoryId)
            const localVarPath = `/api/artifact/repository/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get artifacts by providing repositoryId and fileType
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByRepoIdAndType: async (repositoryId: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getByRepoIdAndType', 'repositoryId', repositoryId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getByRepoIdAndType', 'type', type)
            const localVarPath = `/api/artifact/{repositoryId}/{type}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifact/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStarred: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifact/starred`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('lockArtifact', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/{artifactId}/lock`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} typedTitle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifacts: async (typedTitle: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typedTitle' is not null or undefined
            assertParamExists('searchArtifacts', 'typedTitle', typedTitle)
            const localVarPath = `/api/artifact/search/{typedTitle}`
                .replace(`{${"typedTitle"}}`, encodeURIComponent(String(typedTitle)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStarred: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('setStarred', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/starred/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('unlockArtifact', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/{artifactId}/unlock`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifact: async (artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updateArtifact', 'artifactId', artifactId)
            // verify required parameter 'artifactUpdateTO' is not null or undefined
            assertParamExists('updateArtifact', 'artifactUpdateTO', artifactUpdateTO)
            const localVarPath = `/api/artifact/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifactUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactSVGUploadTO} artifactSVGUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreviewSVG: async (artifactId: string, artifactSVGUploadTO: ArtifactSVGUploadTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updatePreviewSVG', 'artifactId', artifactId)
            // verify required parameter 'artifactSVGUploadTO' is not null or undefined
            assertParamExists('updatePreviewSVG', 'artifactSVGUploadTO', artifactSVGUploadTO)
            const localVarPath = `/api/artifact/previewSVG/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifactSVGUploadTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactApi - functional programming interface
 * @export
 */
export const ArtifactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtifactApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} repositoryId 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyToRepository(repositoryId: string, artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyToRepository(repositoryId, artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {NewArtifactTO} newArtifactTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArtifact(repositoryId: string, newArtifactTO: NewArtifactTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArtifact(repositoryId, newArtifactTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete one Artifact and all of its versions
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifact(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFileTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTypeTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFileTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifact(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactsFromRepo(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactsFromRepo(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get artifacts by providing repositoryId and fileType
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByRepoIdAndType(repositoryId: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByRepoIdAndType(repositoryId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecent(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStarred(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStarred(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockArtifact(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} typedTitle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchArtifacts(typedTitle: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchArtifacts(typedTitle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setStarred(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setStarred(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockArtifact(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtifact(artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArtifact(artifactId, artifactUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactSVGUploadTO} artifactSVGUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePreviewSVG(artifactId: string, artifactSVGUploadTO: ArtifactSVGUploadTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePreviewSVG(artifactId, artifactSVGUploadTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtifactApi - factory interface
 * @export
 */
export const ArtifactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtifactApiFp(configuration)
    return {
        /**
         * 
         * @param {string} repositoryId 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyToRepository(repositoryId: string, artifactId: string, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.copyToRepository(repositoryId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {NewArtifactTO} newArtifactTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(repositoryId: string, newArtifactTO: NewArtifactTO, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.createArtifact(repositoryId, newArtifactTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete one Artifact and all of its versions
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFileTypes(options?: any): AxiosPromise<Array<ArtifactTypeTO>> {
            return localVarFp.getAllFileTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifact(artifactId: string, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.getArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsFromRepo(repositoryId: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getArtifactsFromRepo(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get artifacts by providing repositoryId and fileType
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByRepoIdAndType(repositoryId: string, type: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getByRepoIdAndType(repositoryId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent(options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getRecent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStarred(options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getStarred(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockArtifact(artifactId: string, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.lockArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} typedTitle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifacts(typedTitle: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.searchArtifacts(typedTitle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStarred(artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.setStarred(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockArtifact(artifactId: string, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.unlockArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifact(artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.updateArtifact(artifactId, artifactUpdateTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactSVGUploadTO} artifactSVGUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreviewSVG(artifactId: string, artifactSVGUploadTO: ArtifactSVGUploadTO, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.updatePreviewSVG(artifactId, artifactSVGUploadTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactApi - object-oriented interface
 * @export
 * @class ArtifactApi
 * @extends {BaseAPI}
 */
export class ArtifactApi extends BaseAPI {
    /**
     * 
     * @param {string} repositoryId 
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public copyToRepository(repositoryId: string, artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).copyToRepository(repositoryId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repositoryId 
     * @param {NewArtifactTO} newArtifactTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public createArtifact(repositoryId: string, newArtifactTO: NewArtifactTO, options?: any) {
        return ArtifactApiFp(this.configuration).createArtifact(repositoryId, newArtifactTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete one Artifact and all of its versions
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public deleteArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).deleteArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getAllFileTypes(options?: any) {
        return ArtifactApiFp(this.configuration).getAllFileTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).getArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getArtifactsFromRepo(repositoryId: string, options?: any) {
        return ArtifactApiFp(this.configuration).getArtifactsFromRepo(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get artifacts by providing repositoryId and fileType
     * @param {string} repositoryId 
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getByRepoIdAndType(repositoryId: string, type: string, options?: any) {
        return ArtifactApiFp(this.configuration).getByRepoIdAndType(repositoryId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getRecent(options?: any) {
        return ArtifactApiFp(this.configuration).getRecent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getStarred(options?: any) {
        return ArtifactApiFp(this.configuration).getStarred(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public lockArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).lockArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} typedTitle 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public searchArtifacts(typedTitle: string, options?: any) {
        return ArtifactApiFp(this.configuration).searchArtifacts(typedTitle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public setStarred(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).setStarred(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public unlockArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).unlockArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {ArtifactUpdateTO} artifactUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public updateArtifact(artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any) {
        return ArtifactApiFp(this.configuration).updateArtifact(artifactId, artifactUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {ArtifactSVGUploadTO} artifactSVGUploadTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public updatePreviewSVG(artifactId: string, artifactSVGUploadTO: ArtifactSVGUploadTO, options?: any) {
        return ArtifactApiFp(this.configuration).updatePreviewSVG(artifactId, artifactSVGUploadTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AssignmentApi - axios parameter creator
 * @export
 */
export const AssignmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create user assignment
         * @param {AssignmentUpdateTO} assignmentUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAssignment: async (assignmentUpdateTO: AssignmentUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'assignmentUpdateTO' is not null or undefined
            assertParamExists('createUserAssignment', 'assignmentUpdateTO', assignmentUpdateTO)
            const localVarPath = `/api/assignment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignmentUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user assignment
         * @param {string} repositoryId 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAssignment: async (repositoryId: string, username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('deleteUserAssignment', 'repositoryId', repositoryId)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deleteUserAssignment', 'username', username)
            const localVarPath = `/api/assignment/{repositoryId}/{username}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all assigned users
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssignedUsers: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getAllAssignedUsers', 'repositoryId', repositoryId)
            const localVarPath = `/api/assignment/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user assignment
         * @param {AssignmentUpdateTO} assignmentUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAssignment: async (assignmentUpdateTO: AssignmentUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'assignmentUpdateTO' is not null or undefined
            assertParamExists('updateUserAssignment', 'assignmentUpdateTO', assignmentUpdateTO)
            const localVarPath = `/api/assignment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignmentUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssignmentApi - functional programming interface
 * @export
 */
export const AssignmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssignmentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create user assignment
         * @param {AssignmentUpdateTO} assignmentUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserAssignment(assignmentUpdateTO: AssignmentUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAssignment(assignmentUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete user assignment
         * @param {string} repositoryId 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserAssignment(repositoryId: string, username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserAssignment(repositoryId, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all assigned users
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAssignedUsers(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssignmentTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAssignedUsers(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user assignment
         * @param {AssignmentUpdateTO} assignmentUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserAssignment(assignmentUpdateTO: AssignmentUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserAssignment(assignmentUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssignmentApi - factory interface
 * @export
 */
export const AssignmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssignmentApiFp(configuration)
    return {
        /**
         * 
         * @summary Create user assignment
         * @param {AssignmentUpdateTO} assignmentUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAssignment(assignmentUpdateTO: AssignmentUpdateTO, options?: any): AxiosPromise<AssignmentTO> {
            return localVarFp.createUserAssignment(assignmentUpdateTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user assignment
         * @param {string} repositoryId 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAssignment(repositoryId: string, username: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserAssignment(repositoryId, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all assigned users
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssignedUsers(repositoryId: string, options?: any): AxiosPromise<Array<AssignmentTO>> {
            return localVarFp.getAllAssignedUsers(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user assignment
         * @param {AssignmentUpdateTO} assignmentUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAssignment(assignmentUpdateTO: AssignmentUpdateTO, options?: any): AxiosPromise<AssignmentTO> {
            return localVarFp.updateUserAssignment(assignmentUpdateTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssignmentApi - object-oriented interface
 * @export
 * @class AssignmentApi
 * @extends {BaseAPI}
 */
export class AssignmentApi extends BaseAPI {
    /**
     * 
     * @summary Create user assignment
     * @param {AssignmentUpdateTO} assignmentUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssignmentApi
     */
    public createUserAssignment(assignmentUpdateTO: AssignmentUpdateTO, options?: any) {
        return AssignmentApiFp(this.configuration).createUserAssignment(assignmentUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user assignment
     * @param {string} repositoryId 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssignmentApi
     */
    public deleteUserAssignment(repositoryId: string, username: string, options?: any) {
        return AssignmentApiFp(this.configuration).deleteUserAssignment(repositoryId, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all assigned users
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssignmentApi
     */
    public getAllAssignedUsers(repositoryId: string, options?: any) {
        return AssignmentApiFp(this.configuration).getAllAssignedUsers(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user assignment
     * @param {AssignmentUpdateTO} assignmentUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssignmentApi
     */
    public updateUserAssignment(assignmentUpdateTO: AssignmentUpdateTO, options?: any) {
        return AssignmentApiFp(this.configuration).updateUserAssignment(assignmentUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deploy artifact version
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {NewDeploymentTO} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployVersion: async (artifactId: string, versionId: string, newDeploymentTO: NewDeploymentTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deployVersion', 'artifactId', artifactId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('deployVersion', 'versionId', versionId)
            // verify required parameter 'newDeploymentTO' is not null or undefined
            assertParamExists('deployVersion', 'newDeploymentTO', newDeploymentTO)
            const localVarPath = `/api/deploy/{artifactId}/{versionId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newDeploymentTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all available deployment targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDeploymentTargets: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/deploy/target`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentApiAxiosParamCreator(configuration)
    return {
        /**
         * Deploy artifact version
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {NewDeploymentTO} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployVersion(artifactId: string, versionId: string, newDeploymentTO: NewDeploymentTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactVersionTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployVersion(artifactId, versionId, newDeploymentTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all available deployment targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDeploymentTargets(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDeploymentTargets(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentApiFp(configuration)
    return {
        /**
         * Deploy artifact version
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {NewDeploymentTO} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployVersion(artifactId: string, versionId: string, newDeploymentTO: NewDeploymentTO, options?: any): AxiosPromise<ArtifactVersionTO> {
            return localVarFp.deployVersion(artifactId, versionId, newDeploymentTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all available deployment targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDeploymentTargets(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getAllDeploymentTargets(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * Deploy artifact version
     * @param {string} artifactId 
     * @param {string} versionId 
     * @param {NewDeploymentTO} newDeploymentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public deployVersion(artifactId: string, versionId: string, newDeploymentTO: NewDeploymentTO, options?: any) {
        return DeploymentApiFp(this.configuration).deployVersion(artifactId, versionId, newDeploymentTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all available deployment targets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getAllDeploymentTargets(options?: any) {
        return DeploymentApiFp(this.configuration).getAllDeploymentTargets(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MenuApi - axios parameter creator
 * @export
 */
export const MenuApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMenuItems: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/menu`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MenuApi - functional programming interface
 * @export
 */
export const MenuApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MenuApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMenuItems(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MenuItemTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMenuItems(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MenuApi - factory interface
 * @export
 */
export const MenuApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MenuApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMenuItems(options?: any): AxiosPromise<Array<MenuItemTO>> {
            return localVarFp.getAllMenuItems(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MenuApi - object-oriented interface
 * @export
 * @class MenuApi
 * @extends {BaseAPI}
 */
export class MenuApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public getAllMenuItems(options?: any) {
        return MenuApiFp(this.configuration).getAllMenuItems(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepositoryApi - axios parameter creator
 * @export
 */
export const RepositoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewRepositoryTO} newRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepository: async (newRepositoryTO: NewRepositoryTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newRepositoryTO' is not null or undefined
            assertParamExists('createRepository', 'newRepositoryTO', newRepositoryTO)
            const localVarPath = `/api/repo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newRepositoryTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('deleteRepository', 'repositoryId', repositoryId)
            const localVarPath = `/api/repo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositories: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/repo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all repositories that can be managed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManageableRepositories: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/repo/administration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRepository: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getSingleRepository', 'repositoryId', repositoryId)
            const localVarPath = `/api/repo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for repositories by name
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRepositories: async (typedName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typedName' is not null or undefined
            assertParamExists('searchRepositories', 'typedName', typedName)
            const localVarPath = `/api/repo/search/{typedName}`
                .replace(`{${"typedName"}}`, encodeURIComponent(String(typedName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Repository
         * @param {string} repositoryId 
         * @param {RepositoryUpdateTO} repositoryUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepository: async (repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('updateRepository', 'repositoryId', repositoryId)
            // verify required parameter 'repositoryUpdateTO' is not null or undefined
            assertParamExists('updateRepository', 'repositoryUpdateTO', repositoryUpdateTO)
            const localVarPath = `/api/repo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repositoryUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryApi - functional programming interface
 * @export
 */
export const RepositoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewRepositoryTO} newRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepository(newRepositoryTO: NewRepositoryTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepository(newRepositoryTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepository(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepository(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRepositories(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRepositories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all repositories that can be managed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManageableRepositories(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManageableRepositories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleRepository(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleRepository(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for repositories by name
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchRepositories(typedName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRepositories(typedName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Repository
         * @param {string} repositoryId 
         * @param {RepositoryUpdateTO} repositoryUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepository(repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepository(repositoryId, repositoryUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoryApi - factory interface
 * @export
 */
export const RepositoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewRepositoryTO} newRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepository(newRepositoryTO: NewRepositoryTO, options?: any): AxiosPromise<RepositoryTO> {
            return localVarFp.createRepository(newRepositoryTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository(repositoryId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRepository(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositories(options?: any): AxiosPromise<Array<RepositoryTO>> {
            return localVarFp.getAllRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all repositories that can be managed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManageableRepositories(options?: any): AxiosPromise<Array<RepositoryTO>> {
            return localVarFp.getManageableRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRepository(repositoryId: string, options?: any): AxiosPromise<RepositoryTO> {
            return localVarFp.getSingleRepository(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for repositories by name
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRepositories(typedName: string, options?: any): AxiosPromise<Array<RepositoryTO>> {
            return localVarFp.searchRepositories(typedName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Repository
         * @param {string} repositoryId 
         * @param {RepositoryUpdateTO} repositoryUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepository(repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options?: any): AxiosPromise<RepositoryTO> {
            return localVarFp.updateRepository(repositoryId, repositoryUpdateTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoryApi - object-oriented interface
 * @export
 * @class RepositoryApi
 * @extends {BaseAPI}
 */
export class RepositoryApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Repository
     * @param {NewRepositoryTO} newRepositoryTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public createRepository(newRepositoryTO: NewRepositoryTO, options?: any) {
        return RepositoryApiFp(this.configuration).createRepository(newRepositoryTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Repository if you own it
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public deleteRepository(repositoryId: string, options?: any) {
        return RepositoryApiFp(this.configuration).deleteRepository(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all Repositories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getAllRepositories(options?: any) {
        return RepositoryApiFp(this.configuration).getAllRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all repositories that can be managed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getManageableRepositories(options?: any) {
        return RepositoryApiFp(this.configuration).getManageableRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Repository by providing its ID
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getSingleRepository(repositoryId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getSingleRepository(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for repositories by name
     * @param {string} typedName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public searchRepositories(typedName: string, options?: any) {
        return RepositoryApiFp(this.configuration).searchRepositories(typedName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Repository
     * @param {string} repositoryId 
     * @param {RepositoryUpdateTO} repositoryUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public updateRepository(repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options?: any) {
        return RepositoryApiFp(this.configuration).updateRepository(repositoryId, repositoryUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShareApi - axios parameter creator
 * @export
 */
export const ShareApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all shared Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedArtifacts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/share/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Artifacts shared with Repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifacts: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getSharedArtifacts', 'repositoryId', repositoryId)
            const localVarPath = `/api/share/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all repositories that can access a specific artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedRepositories: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getSharedRepositories', 'artifactId', artifactId)
            const localVarPath = `/api/share/repository/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Share an artifact with all members of another repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareWithRepository: async (shareWithRepositoryTO: ShareWithRepositoryTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareWithRepositoryTO' is not null or undefined
            assertParamExists('shareWithRepository', 'shareWithRepositoryTO', shareWithRepositoryTO)
            const localVarPath = `/api/share/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareWithRepositoryTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Share an artifact with all members of another team
         * @param {ShareWithTeamTO} shareWithTeamTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareWithTeam: async (shareWithTeamTO: ShareWithTeamTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareWithTeamTO' is not null or undefined
            assertParamExists('shareWithTeam', 'shareWithTeamTO', shareWithTeamTO)
            const localVarPath = `/api/share/team`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareWithTeamTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareArtifactWithRepository: async (artifactId: string, repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('unshareArtifactWithRepository', 'artifactId', artifactId)
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('unshareArtifactWithRepository', 'repositoryId', repositoryId)
            const localVarPath = `/api/share/repository/unshare/{artifactId}/{repositoryId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareArtifactWithTeam: async (artifactId: string, teamId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('unshareArtifactWithTeam', 'artifactId', artifactId)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('unshareArtifactWithTeam', 'teamId', teamId)
            const localVarPath = `/api/share/team/unshare/{artifactId}/{teamId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the share-role of a relation with a repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareWithRepository: async (shareWithRepositoryTO: ShareWithRepositoryTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareWithRepositoryTO' is not null or undefined
            assertParamExists('updateShareWithRepository', 'shareWithRepositoryTO', shareWithRepositoryTO)
            const localVarPath = `/api/share/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareWithRepositoryTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the share-role of a relation with a team
         * @param {ShareWithTeamTO} shareWithTeamTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareWithTeam: async (shareWithTeamTO: ShareWithTeamTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareWithTeamTO' is not null or undefined
            assertParamExists('updateShareWithTeam', 'shareWithTeamTO', shareWithTeamTO)
            const localVarPath = `/api/share/team`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareWithTeamTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShareApi - functional programming interface
 * @export
 */
export const ShareApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShareApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all shared Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSharedArtifacts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSharedArtifacts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Artifacts shared with Repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedArtifacts(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedArtifacts(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all repositories that can access a specific artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedRepositories(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedRepositories(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Share an artifact with all members of another repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareWithRepositoryTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareWithRepository(shareWithRepositoryTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Share an artifact with all members of another team
         * @param {ShareWithTeamTO} shareWithTeamTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareWithTeam(shareWithTeamTO: ShareWithTeamTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareWithTeamTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareWithTeam(shareWithTeamTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unshareArtifactWithRepository(artifactId: string, repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unshareArtifactWithRepository(artifactId, repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unshareArtifactWithTeam(artifactId: string, teamId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unshareArtifactWithTeam(artifactId, teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the share-role of a relation with a repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareWithRepositoryTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShareWithRepository(shareWithRepositoryTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the share-role of a relation with a team
         * @param {ShareWithTeamTO} shareWithTeamTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShareWithTeam(shareWithTeamTO: ShareWithTeamTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareWithTeamTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShareWithTeam(shareWithTeamTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShareApi - factory interface
 * @export
 */
export const ShareApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShareApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all shared Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedArtifacts(options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getAllSharedArtifacts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Artifacts shared with Repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifacts(repositoryId: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getSharedArtifacts(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all repositories that can access a specific artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedRepositories(artifactId: string, options?: any): AxiosPromise<Array<RepositoryTO>> {
            return localVarFp.getSharedRepositories(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Share an artifact with all members of another repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any): AxiosPromise<ShareWithRepositoryTO> {
            return localVarFp.shareWithRepository(shareWithRepositoryTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Share an artifact with all members of another team
         * @param {ShareWithTeamTO} shareWithTeamTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareWithTeam(shareWithTeamTO: ShareWithTeamTO, options?: any): AxiosPromise<ShareWithTeamTO> {
            return localVarFp.shareWithTeam(shareWithTeamTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareArtifactWithRepository(artifactId: string, repositoryId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unshareArtifactWithRepository(artifactId, repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareArtifactWithTeam(artifactId: string, teamId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unshareArtifactWithTeam(artifactId, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the share-role of a relation with a repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any): AxiosPromise<ShareWithRepositoryTO> {
            return localVarFp.updateShareWithRepository(shareWithRepositoryTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the share-role of a relation with a team
         * @param {ShareWithTeamTO} shareWithTeamTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareWithTeam(shareWithTeamTO: ShareWithTeamTO, options?: any): AxiosPromise<ShareWithTeamTO> {
            return localVarFp.updateShareWithTeam(shareWithTeamTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShareApi - object-oriented interface
 * @export
 * @class ShareApi
 * @extends {BaseAPI}
 */
export class ShareApi extends BaseAPI {
    /**
     * 
     * @summary Get all shared Artifacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getAllSharedArtifacts(options?: any) {
        return ShareApiFp(this.configuration).getAllSharedArtifacts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Artifacts shared with Repository
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedArtifacts(repositoryId: string, options?: any) {
        return ShareApiFp(this.configuration).getSharedArtifacts(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all repositories that can access a specific artifact
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedRepositories(artifactId: string, options?: any) {
        return ShareApiFp(this.configuration).getSharedRepositories(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Share an artifact with all members of another repository
     * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public shareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any) {
        return ShareApiFp(this.configuration).shareWithRepository(shareWithRepositoryTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Share an artifact with all members of another team
     * @param {ShareWithTeamTO} shareWithTeamTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public shareWithTeam(shareWithTeamTO: ShareWithTeamTO, options?: any) {
        return ShareApiFp(this.configuration).shareWithTeam(shareWithTeamTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the sharing-relation to a specific repository
     * @param {string} artifactId 
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public unshareArtifactWithRepository(artifactId: string, repositoryId: string, options?: any) {
        return ShareApiFp(this.configuration).unshareArtifactWithRepository(artifactId, repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the sharing-relation to a specific repository
     * @param {string} artifactId 
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public unshareArtifactWithTeam(artifactId: string, teamId: string, options?: any) {
        return ShareApiFp(this.configuration).unshareArtifactWithTeam(artifactId, teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the share-role of a relation with a repository
     * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public updateShareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any) {
        return ShareApiFp(this.configuration).updateShareWithRepository(shareWithRepositoryTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the share-role of a relation with a team
     * @param {ShareWithTeamTO} shareWithTeamTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public updateShareWithTeam(shareWithTeamTO: ShareWithTeamTO, options?: any) {
        return ShareApiFp(this.configuration).updateShareWithTeam(shareWithTeamTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/currentUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserName: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/registeredEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: async (typedName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typedName' is not null or undefined
            assertParamExists('searchUsers', 'typedName', typedName)
            const localVarPath = `/api/user/search/{typedName}`
                .replace(`{${"typedName"}}`, encodeURIComponent(String(typedName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserUpdateTO} userUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userUpdateTO: UserUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdateTO' is not null or undefined
            assertParamExists('updateUser', 'userUpdateTO', userUpdateTO)
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserName(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserName(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers(typedName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfoTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsers(typedName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UserUpdateTO} userUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userUpdateTO: UserUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(options?: any): AxiosPromise<UserTO> {
            return localVarFp.createUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: any): AxiosPromise<UserInfoTO> {
            return localVarFp.getUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserName(options?: any): AxiosPromise<string> {
            return localVarFp.getUserName(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(typedName: string, options?: any): AxiosPromise<Array<UserInfoTO>> {
            return localVarFp.searchUsers(typedName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserUpdateTO} userUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userUpdateTO: UserUpdateTO, options?: any): AxiosPromise<User> {
            return localVarFp.updateUser(userUpdateTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(options?: any) {
        return UserApiFp(this.configuration).createUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserInfo(options?: any) {
        return UserApiFp(this.configuration).getUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserName(options?: any) {
        return UserApiFp(this.configuration).getUserName(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} typedName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public searchUsers(typedName: string, options?: any) {
        return UserApiFp(this.configuration).searchUsers(typedName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserUpdateTO} userUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(userUpdateTO: UserUpdateTO, options?: any) {
        return UserApiFp(this.configuration).updateUser(userUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VersionApi - axios parameter creator
 * @export
 */
export const VersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactVersionUploadTO} artifactVersionUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVersion: async (artifactId: string, artifactVersionUploadTO: ArtifactVersionUploadTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('createVersion', 'artifactId', artifactId)
            // verify required parameter 'artifactVersionUploadTO' is not null or undefined
            assertParamExists('createVersion', 'artifactVersionUploadTO', artifactVersionUploadTO)
            const localVarPath = `/api/version/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifactVersionUploadTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadVersion: async (artifactId: string, versionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('downloadVersion', 'artifactId', artifactId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('downloadVersion', 'versionId', versionId)
            const localVarPath = `/api/version/{artifactId}/version/{versionId}/download`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVersions: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getAllVersions', 'artifactId', artifactId)
            const localVarPath = `/api/version/{artifactId}/version`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the latest version of the requested artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestVersion: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getLatestVersion', 'artifactId', artifactId)
            const localVarPath = `/api/version/{artifactId}/version/latest`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (artifactId: string, versionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getVersion', 'artifactId', artifactId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getVersion', 'versionId', versionId)
            const localVarPath = `/api/version/{artifactId}/version/{versionId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ArtifactVersionUpdateTO} artifactVersionUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVersion: async (artifactVersionUpdateTO: ArtifactVersionUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactVersionUpdateTO' is not null or undefined
            assertParamExists('updateVersion', 'artifactVersionUpdateTO', artifactVersionUpdateTO)
            const localVarPath = `/api/version/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifactVersionUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionApi - functional programming interface
 * @export
 */
export const VersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactVersionUploadTO} artifactVersionUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVersion(artifactId: string, artifactVersionUploadTO: ArtifactVersionUploadTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactVersionTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVersion(artifactId, artifactVersionUploadTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadVersion(artifactId: string, versionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadVersion(artifactId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllVersions(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactVersionTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllVersions(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the latest version of the requested artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestVersion(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactVersionTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestVersion(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(artifactId: string, versionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactVersionTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(artifactId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ArtifactVersionUpdateTO} artifactVersionUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVersion(artifactVersionUpdateTO: ArtifactVersionUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactVersionTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVersion(artifactVersionUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VersionApi - factory interface
 * @export
 */
export const VersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionApiFp(configuration)
    return {
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactVersionUploadTO} artifactVersionUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVersion(artifactId: string, artifactVersionUploadTO: ArtifactVersionUploadTO, options?: any): AxiosPromise<ArtifactVersionTO> {
            return localVarFp.createVersion(artifactId, artifactVersionUploadTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadVersion(artifactId: string, versionId: string, options?: any): AxiosPromise<any> {
            return localVarFp.downloadVersion(artifactId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVersions(artifactId: string, options?: any): AxiosPromise<Array<ArtifactVersionTO>> {
            return localVarFp.getAllVersions(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the latest version of the requested artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestVersion(artifactId: string, options?: any): AxiosPromise<ArtifactVersionTO> {
            return localVarFp.getLatestVersion(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(artifactId: string, versionId: string, options?: any): AxiosPromise<ArtifactVersionTO> {
            return localVarFp.getVersion(artifactId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ArtifactVersionUpdateTO} artifactVersionUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVersion(artifactVersionUpdateTO: ArtifactVersionUpdateTO, options?: any): AxiosPromise<ArtifactVersionTO> {
            return localVarFp.updateVersion(artifactVersionUpdateTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export class VersionApi extends BaseAPI {
    /**
     * 
     * @param {string} artifactId 
     * @param {ArtifactVersionUploadTO} artifactVersionUploadTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public createVersion(artifactId: string, artifactVersionUploadTO: ArtifactVersionUploadTO, options?: any) {
        return VersionApiFp(this.configuration).createVersion(artifactId, artifactVersionUploadTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {string} versionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public downloadVersion(artifactId: string, versionId: string, options?: any) {
        return VersionApiFp(this.configuration).downloadVersion(artifactId, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public getAllVersions(artifactId: string, options?: any) {
        return VersionApiFp(this.configuration).getAllVersions(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the latest version of the requested artifact
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public getLatestVersion(artifactId: string, options?: any) {
        return VersionApiFp(this.configuration).getLatestVersion(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {string} versionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public getVersion(artifactId: string, versionId: string, options?: any) {
        return VersionApiFp(this.configuration).getVersion(artifactId, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ArtifactVersionUpdateTO} artifactVersionUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public updateVersion(artifactVersionUpdateTO: ArtifactVersionUpdateTO, options?: any) {
        return VersionApiFp(this.configuration).updateVersion(artifactVersionUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }
}


