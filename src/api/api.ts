/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ArtifactSVGUploadTO
 */
export interface ArtifactSVGUploadTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactSVGUploadTO
     */
    svgPreview: string;
}
/**
 * 
 * @export
 * @interface ArtifactTO
 */
export interface ArtifactTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    createdDate: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    updatedDate: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    svgPreview?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    fileType: string;
}
/**
 * 
 * @export
 * @interface ArtifactTypeTO
 */
export interface ArtifactTypeTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    fileExtension: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    svgIcon: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    url: string;
}
/**
 * 
 * @export
 * @interface ArtifactUpdateTO
 */
export interface ArtifactUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    fileType?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    svgPreview?: string;
}
/**
 * 
 * @export
 * @interface ArtifactVersionTO
 */
export interface ArtifactVersionTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionTO
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof ArtifactVersionTO
     */
    milestone: number;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionTO
     */
    xml: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionTO
     */
    saveType: ArtifactVersionTOSaveTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionTO
     */
    updatedDate: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionTO
     */
    artifactId: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionTO
     */
    repositoryId: string;
    /**
     * 
     * @type {Array<DeploymentTO>}
     * @memberof ArtifactVersionTO
     */
    deployments: Array<DeploymentTO>;
}

/**
    * @export
    * @enum {string}
    */
export enum ArtifactVersionTOSaveTypeEnum {
    Milestone = 'MILESTONE',
    Autosave = 'AUTOSAVE'
}

/**
 * 
 * @export
 * @interface ArtifactVersionUploadTO
 */
export interface ArtifactVersionUploadTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionUploadTO
     */
    versionComment?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionUploadTO
     */
    xml?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactVersionUploadTO
     */
    saveType?: ArtifactVersionUploadTOSaveTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ArtifactVersionUploadTOSaveTypeEnum {
    Milestone = 'MILESTONE',
    Autosave = 'AUTOSAVE'
}

/**
 * 
 * @export
 * @interface AssignmentTO
 */
export interface AssignmentTO {
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    roleEnum: AssignmentTORoleEnumEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AssignmentTORoleEnumEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * 
 * @export
 * @interface AssignmentUpdateTO
 */
export interface AssignmentUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof AssignmentUpdateTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentUpdateTO
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentUpdateTO
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentUpdateTO
     */
    roleEnum: AssignmentUpdateTORoleEnumEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AssignmentUpdateTORoleEnumEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * 
 * @export
 * @interface DeploymentTO
 */
export interface DeploymentTO {
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    target: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    user: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    timestamp: string;
}
/**
 * 
 * @export
 * @interface MenuItemTO
 */
export interface MenuItemTO {
    /**
     * 
     * @type {string}
     * @memberof MenuItemTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MenuItemTO
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof MenuItemTO
     */
    icon: string;
    /**
     * 
     * @type {number}
     * @memberof MenuItemTO
     */
    position?: number;
}
/**
 * 
 * @export
 * @interface NewArtifactTO
 */
export interface NewArtifactTO {
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    fileType: string;
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    svgPreview?: string;
}
/**
 * 
 * @export
 * @interface NewDeploymentTO
 */
export interface NewDeploymentTO {
    /**
     * 
     * @type {string}
     * @memberof NewDeploymentTO
     */
    target: string;
}
/**
 * 
 * @export
 * @interface NewRepositoryTO
 */
export interface NewRepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof NewRepositoryTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewRepositoryTO
     */
    description: string;
}
/**
 * 
 * @export
 * @interface RepositoryTO
 */
export interface RepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof RepositoryTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryTO
     */
    description: string;
    /**
     * 
     * @type {Array<ArtifactTO>}
     * @memberof RepositoryTO
     */
    sharedArtifacts?: Array<ArtifactTO>;
    /**
     * 
     * @type {number}
     * @memberof RepositoryTO
     */
    existingArtifacts: number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryTO
     */
    assignedUsers: number;
}
/**
 * 
 * @export
 * @interface RepositoryUpdateTO
 */
export interface RepositoryUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof RepositoryUpdateTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryUpdateTO
     */
    description: string;
}
/**
 * 
 * @export
 * @interface UserInfoTO
 */
export interface UserInfoTO {
    /**
     * 
     * @type {string}
     * @memberof UserInfoTO
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoTO
     */
    id: string;
}
/**
 * 
 * @export
 * @interface UserUpdateTO
 */
export interface UserUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateTO
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateTO
     */
    username?: string;
}

/**
 * ArtifactApi - axios parameter creator
 * @export
 */
export const ArtifactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} repositoryId 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyToRepository: async (repositoryId: string, artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('copyToRepository', 'repositoryId', repositoryId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('copyToRepository', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/copy/{repositoryId}/{artifactId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {NewArtifactTO} newArtifactTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact: async (repositoryId: string, newArtifactTO: NewArtifactTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('createArtifact', 'repositoryId', repositoryId)
            // verify required parameter 'newArtifactTO' is not null or undefined
            assertParamExists('createArtifact', 'newArtifactTO', newArtifactTO)
            const localVarPath = `/api/artifact/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newArtifactTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete one Artifact and all of its versions
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deleteArtifact', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFileTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all shared Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedArtifacts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifact/shared`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifact', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsFromRepo: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getArtifactsFromRepo', 'repositoryId', repositoryId)
            const localVarPath = `/api/artifact/repository/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByRepoIdAndType: async (repositoryId: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getByRepoIdAndType', 'repositoryId', repositoryId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getByRepoIdAndType', 'type', type)
            const localVarPath = `/api/artifact/{repositoryId}/{type}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifact/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStarred: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifact/starred`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('lockArtifact', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/{artifactId}/lock`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} typedTitle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifacts: async (typedTitle: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typedTitle' is not null or undefined
            assertParamExists('searchArtifacts', 'typedTitle', typedTitle)
            const localVarPath = `/api/artifact/search/{typedTitle}`
                .replace(`{${"typedTitle"}}`, encodeURIComponent(String(typedTitle)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStarred: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('setStarred', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/starred/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Share an Artifact with all members of another Repository
         * @param {string} artifactId 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareWithRepository: async (artifactId: string, requestBody: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('shareWithRepository', 'artifactId', artifactId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('shareWithRepository', 'requestBody', requestBody)
            const localVarPath = `/api/artifact/share/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('unlockArtifact', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/{artifactId}/unlock`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifact: async (artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updateArtifact', 'artifactId', artifactId)
            // verify required parameter 'artifactUpdateTO' is not null or undefined
            assertParamExists('updateArtifact', 'artifactUpdateTO', artifactUpdateTO)
            const localVarPath = `/api/artifact/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifactUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactSVGUploadTO} artifactSVGUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreviewSVG: async (artifactId: string, artifactSVGUploadTO: ArtifactSVGUploadTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updatePreviewSVG', 'artifactId', artifactId)
            // verify required parameter 'artifactSVGUploadTO' is not null or undefined
            assertParamExists('updatePreviewSVG', 'artifactSVGUploadTO', artifactSVGUploadTO)
            const localVarPath = `/api/artifact/previewSVG/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifactSVGUploadTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactApi - functional programming interface
 * @export
 */
export const ArtifactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtifactApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} repositoryId 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyToRepository(repositoryId: string, artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyToRepository(repositoryId, artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {NewArtifactTO} newArtifactTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArtifact(repositoryId: string, newArtifactTO: NewArtifactTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArtifact(repositoryId, newArtifactTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete one Artifact and all of its versions
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifact(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFileTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTypeTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFileTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all shared Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSharedArtifacts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSharedArtifacts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifact(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactsFromRepo(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactsFromRepo(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByRepoIdAndType(repositoryId: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByRepoIdAndType(repositoryId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecent(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStarred(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStarred(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockArtifact(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} typedTitle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchArtifacts(typedTitle: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchArtifacts(typedTitle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setStarred(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setStarred(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Share an Artifact with all members of another Repository
         * @param {string} artifactId 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareWithRepository(artifactId: string, requestBody: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareWithRepository(artifactId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockArtifact(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtifact(artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArtifact(artifactId, artifactUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactSVGUploadTO} artifactSVGUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePreviewSVG(artifactId: string, artifactSVGUploadTO: ArtifactSVGUploadTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePreviewSVG(artifactId, artifactSVGUploadTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtifactApi - factory interface
 * @export
 */
export const ArtifactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtifactApiFp(configuration)
    return {
        /**
         * 
         * @param {string} repositoryId 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyToRepository(repositoryId: string, artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.copyToRepository(repositoryId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {NewArtifactTO} newArtifactTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(repositoryId: string, newArtifactTO: NewArtifactTO, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.createArtifact(repositoryId, newArtifactTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete one Artifact and all of its versions
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFileTypes(options?: any): AxiosPromise<Array<ArtifactTypeTO>> {
            return localVarFp.getAllFileTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all shared Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedArtifacts(options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getAllSharedArtifacts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifact(artifactId: string, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.getArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsFromRepo(repositoryId: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getArtifactsFromRepo(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByRepoIdAndType(repositoryId: string, type: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getByRepoIdAndType(repositoryId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent(options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getRecent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStarred(options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getStarred(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockArtifact(artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.lockArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} typedTitle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifacts(typedTitle: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.searchArtifacts(typedTitle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStarred(artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.setStarred(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Share an Artifact with all members of another Repository
         * @param {string} artifactId 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareWithRepository(artifactId: string, requestBody: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.shareWithRepository(artifactId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockArtifact(artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unlockArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifact(artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.updateArtifact(artifactId, artifactUpdateTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactSVGUploadTO} artifactSVGUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePreviewSVG(artifactId: string, artifactSVGUploadTO: ArtifactSVGUploadTO, options?: any): AxiosPromise<void> {
            return localVarFp.updatePreviewSVG(artifactId, artifactSVGUploadTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactApi - object-oriented interface
 * @export
 * @class ArtifactApi
 * @extends {BaseAPI}
 */
export class ArtifactApi extends BaseAPI {
    /**
     * 
     * @param {string} repositoryId 
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public copyToRepository(repositoryId: string, artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).copyToRepository(repositoryId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repositoryId 
     * @param {NewArtifactTO} newArtifactTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public createArtifact(repositoryId: string, newArtifactTO: NewArtifactTO, options?: any) {
        return ArtifactApiFp(this.configuration).createArtifact(repositoryId, newArtifactTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete one Artifact and all of its versions
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public deleteArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).deleteArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getAllFileTypes(options?: any) {
        return ArtifactApiFp(this.configuration).getAllFileTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all shared Artifacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getAllSharedArtifacts(options?: any) {
        return ArtifactApiFp(this.configuration).getAllSharedArtifacts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).getArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getArtifactsFromRepo(repositoryId: string, options?: any) {
        return ArtifactApiFp(this.configuration).getArtifactsFromRepo(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} repositoryId 
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getByRepoIdAndType(repositoryId: string, type: string, options?: any) {
        return ArtifactApiFp(this.configuration).getByRepoIdAndType(repositoryId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getRecent(options?: any) {
        return ArtifactApiFp(this.configuration).getRecent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getStarred(options?: any) {
        return ArtifactApiFp(this.configuration).getStarred(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public lockArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).lockArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} typedTitle 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public searchArtifacts(typedTitle: string, options?: any) {
        return ArtifactApiFp(this.configuration).searchArtifacts(typedTitle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public setStarred(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).setStarred(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Share an Artifact with all members of another Repository
     * @param {string} artifactId 
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public shareWithRepository(artifactId: string, requestBody: Array<string>, options?: any) {
        return ArtifactApiFp(this.configuration).shareWithRepository(artifactId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public unlockArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).unlockArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {ArtifactUpdateTO} artifactUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public updateArtifact(artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any) {
        return ArtifactApiFp(this.configuration).updateArtifact(artifactId, artifactUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {ArtifactSVGUploadTO} artifactSVGUploadTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public updatePreviewSVG(artifactId: string, artifactSVGUploadTO: ArtifactSVGUploadTO, options?: any) {
        return ArtifactApiFp(this.configuration).updatePreviewSVG(artifactId, artifactSVGUploadTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AssignmentApi - axios parameter creator
 * @export
 */
export const AssignmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create / update user assignment
         * @param {AssignmentUpdateTO} assignmentUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateUserAssignment: async (assignmentUpdateTO: AssignmentUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'assignmentUpdateTO' is not null or undefined
            assertParamExists('createOrUpdateUserAssignment', 'assignmentUpdateTO', assignmentUpdateTO)
            const localVarPath = `/api/assignment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignmentUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user assignment
         * @param {string} repositoryId 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAssignment: async (repositoryId: string, username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('deleteUserAssignment', 'repositoryId', repositoryId)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deleteUserAssignment', 'username', username)
            const localVarPath = `/api/assignment/{repositoryId}/{username}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all assigned users
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssignedUsers: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getAllAssignedUsers', 'repositoryId', repositoryId)
            const localVarPath = `/api/assignment/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssignmentApi - functional programming interface
 * @export
 */
export const AssignmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssignmentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create / update user assignment
         * @param {AssignmentUpdateTO} assignmentUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateUserAssignment(assignmentUpdateTO: AssignmentUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateUserAssignment(assignmentUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete user assignment
         * @param {string} repositoryId 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserAssignment(repositoryId: string, username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserAssignment(repositoryId, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all assigned users
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAssignedUsers(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssignmentTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAssignedUsers(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssignmentApi - factory interface
 * @export
 */
export const AssignmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssignmentApiFp(configuration)
    return {
        /**
         * 
         * @summary Create / update user assignment
         * @param {AssignmentUpdateTO} assignmentUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateUserAssignment(assignmentUpdateTO: AssignmentUpdateTO, options?: any): AxiosPromise<void> {
            return localVarFp.createOrUpdateUserAssignment(assignmentUpdateTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user assignment
         * @param {string} repositoryId 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAssignment(repositoryId: string, username: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserAssignment(repositoryId, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all assigned users
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssignedUsers(repositoryId: string, options?: any): AxiosPromise<Array<AssignmentTO>> {
            return localVarFp.getAllAssignedUsers(repositoryId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssignmentApi - object-oriented interface
 * @export
 * @class AssignmentApi
 * @extends {BaseAPI}
 */
export class AssignmentApi extends BaseAPI {
    /**
     * 
     * @summary Create / update user assignment
     * @param {AssignmentUpdateTO} assignmentUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssignmentApi
     */
    public createOrUpdateUserAssignment(assignmentUpdateTO: AssignmentUpdateTO, options?: any) {
        return AssignmentApiFp(this.configuration).createOrUpdateUserAssignment(assignmentUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user assignment
     * @param {string} repositoryId 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssignmentApi
     */
    public deleteUserAssignment(repositoryId: string, username: string, options?: any) {
        return AssignmentApiFp(this.configuration).deleteUserAssignment(repositoryId, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all assigned users
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssignmentApi
     */
    public getAllAssignedUsers(repositoryId: string, options?: any) {
        return AssignmentApiFp(this.configuration).getAllAssignedUsers(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deploy artifact version
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {NewDeploymentTO} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployVersion: async (artifactId: string, versionId: string, newDeploymentTO: NewDeploymentTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deployVersion', 'artifactId', artifactId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('deployVersion', 'versionId', versionId)
            // verify required parameter 'newDeploymentTO' is not null or undefined
            assertParamExists('deployVersion', 'newDeploymentTO', newDeploymentTO)
            const localVarPath = `/api/deploy/{artifactId}/{versionId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newDeploymentTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all available deployment targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDeploymentTargets: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/deploy/target`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentApiAxiosParamCreator(configuration)
    return {
        /**
         * Deploy artifact version
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {NewDeploymentTO} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployVersion(artifactId: string, versionId: string, newDeploymentTO: NewDeploymentTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployVersion(artifactId, versionId, newDeploymentTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all available deployment targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDeploymentTargets(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDeploymentTargets(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentApiFp(configuration)
    return {
        /**
         * Deploy artifact version
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {NewDeploymentTO} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployVersion(artifactId: string, versionId: string, newDeploymentTO: NewDeploymentTO, options?: any): AxiosPromise<void> {
            return localVarFp.deployVersion(artifactId, versionId, newDeploymentTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all available deployment targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDeploymentTargets(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getAllDeploymentTargets(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * Deploy artifact version
     * @param {string} artifactId 
     * @param {string} versionId 
     * @param {NewDeploymentTO} newDeploymentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public deployVersion(artifactId: string, versionId: string, newDeploymentTO: NewDeploymentTO, options?: any) {
        return DeploymentApiFp(this.configuration).deployVersion(artifactId, versionId, newDeploymentTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all available deployment targets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getAllDeploymentTargets(options?: any) {
        return DeploymentApiFp(this.configuration).getAllDeploymentTargets(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MenuApi - axios parameter creator
 * @export
 */
export const MenuApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMenuItems: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/menu`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MenuApi - functional programming interface
 * @export
 */
export const MenuApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MenuApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMenuItems(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MenuItemTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMenuItems(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MenuApi - factory interface
 * @export
 */
export const MenuApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MenuApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMenuItems(options?: any): AxiosPromise<Array<MenuItemTO>> {
            return localVarFp.getAllMenuItems(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MenuApi - object-oriented interface
 * @export
 * @class MenuApi
 * @extends {BaseAPI}
 */
export class MenuApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public getAllMenuItems(options?: any) {
        return MenuApiFp(this.configuration).getAllMenuItems(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepositoryApi - axios parameter creator
 * @export
 */
export const RepositoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewRepositoryTO} newRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepository: async (newRepositoryTO: NewRepositoryTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newRepositoryTO' is not null or undefined
            assertParamExists('createRepository', 'newRepositoryTO', newRepositoryTO)
            const localVarPath = `/api/bpmnrepo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newRepositoryTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('deleteRepository', 'repositoryId', repositoryId)
            const localVarPath = `/api/bpmnrepo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositories: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bpmnrepo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRepository: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getSingleRepository', 'repositoryId', repositoryId)
            const localVarPath = `/api/bpmnrepo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Repository
         * @param {string} repositoryId 
         * @param {RepositoryUpdateTO} repositoryUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepository: async (repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('updateRepository', 'repositoryId', repositoryId)
            // verify required parameter 'repositoryUpdateTO' is not null or undefined
            assertParamExists('updateRepository', 'repositoryUpdateTO', repositoryUpdateTO)
            const localVarPath = `/api/bpmnrepo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repositoryUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryApi - functional programming interface
 * @export
 */
export const RepositoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewRepositoryTO} newRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepository(newRepositoryTO: NewRepositoryTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepository(newRepositoryTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepository(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepository(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRepositories(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRepositories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleRepository(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleRepository(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Repository
         * @param {string} repositoryId 
         * @param {RepositoryUpdateTO} repositoryUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepository(repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepository(repositoryId, repositoryUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoryApi - factory interface
 * @export
 */
export const RepositoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewRepositoryTO} newRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepository(newRepositoryTO: NewRepositoryTO, options?: any): AxiosPromise<void> {
            return localVarFp.createRepository(newRepositoryTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository(repositoryId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRepository(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositories(options?: any): AxiosPromise<Array<RepositoryTO>> {
            return localVarFp.getAllRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRepository(repositoryId: string, options?: any): AxiosPromise<RepositoryTO> {
            return localVarFp.getSingleRepository(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Repository
         * @param {string} repositoryId 
         * @param {RepositoryUpdateTO} repositoryUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepository(repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options?: any): AxiosPromise<void> {
            return localVarFp.updateRepository(repositoryId, repositoryUpdateTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoryApi - object-oriented interface
 * @export
 * @class RepositoryApi
 * @extends {BaseAPI}
 */
export class RepositoryApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Repository
     * @param {NewRepositoryTO} newRepositoryTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public createRepository(newRepositoryTO: NewRepositoryTO, options?: any) {
        return RepositoryApiFp(this.configuration).createRepository(newRepositoryTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Repository if you own it
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public deleteRepository(repositoryId: string, options?: any) {
        return RepositoryApiFp(this.configuration).deleteRepository(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all Repositories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getAllRepositories(options?: any) {
        return RepositoryApiFp(this.configuration).getAllRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Repository by providing its ID
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getSingleRepository(repositoryId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getSingleRepository(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Repository
     * @param {string} repositoryId 
     * @param {RepositoryUpdateTO} repositoryUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public updateRepository(repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options?: any) {
        return RepositoryApiFp(this.configuration).updateRepository(repositoryId, repositoryUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/currentUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserName: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/registeredEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: async (typedName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typedName' is not null or undefined
            assertParamExists('searchUsers', 'typedName', typedName)
            const localVarPath = `/api/user/searchUsers/{typedName}`
                .replace(`{${"typedName"}}`, encodeURIComponent(String(typedName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserUpdateTO} userUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userUpdateTO: UserUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdateTO' is not null or undefined
            assertParamExists('updateUser', 'userUpdateTO', userUpdateTO)
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserName(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserName(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers(typedName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfoTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsers(typedName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UserUpdateTO} userUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userUpdateTO: UserUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(options?: any): AxiosPromise<void> {
            return localVarFp.createUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: any): AxiosPromise<UserInfoTO> {
            return localVarFp.getUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserName(options?: any): AxiosPromise<string> {
            return localVarFp.getUserName(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(typedName: string, options?: any): AxiosPromise<Array<UserInfoTO>> {
            return localVarFp.searchUsers(typedName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserUpdateTO} userUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userUpdateTO: UserUpdateTO, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(userUpdateTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(options?: any) {
        return UserApiFp(this.configuration).createUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserInfo(options?: any) {
        return UserApiFp(this.configuration).getUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserName(options?: any) {
        return UserApiFp(this.configuration).getUserName(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} typedName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public searchUsers(typedName: string, options?: any) {
        return UserApiFp(this.configuration).searchUsers(typedName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserUpdateTO} userUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(userUpdateTO: UserUpdateTO, options?: any) {
        return UserApiFp(this.configuration).updateUser(userUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VersionApi - axios parameter creator
 * @export
 */
export const VersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactVersionUploadTO} artifactVersionUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateVersion: async (artifactId: string, artifactVersionUploadTO: ArtifactVersionUploadTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('createOrUpdateVersion', 'artifactId', artifactId)
            // verify required parameter 'artifactVersionUploadTO' is not null or undefined
            assertParamExists('createOrUpdateVersion', 'artifactVersionUploadTO', artifactVersionUploadTO)
            const localVarPath = `/api/version/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifactVersionUploadTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadVersion: async (artifactId: string, versionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('downloadVersion', 'artifactId', artifactId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('downloadVersion', 'versionId', versionId)
            const localVarPath = `/api/version/{artifactId}/version/{versionId}/download`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVersions: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getAllVersions', 'artifactId', artifactId)
            const localVarPath = `/api/version/{artifactId}/version`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the latest version of the requested artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestVersion: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getLatestVersion', 'artifactId', artifactId)
            const localVarPath = `/api/version/{artifactId}/version/latest`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (artifactId: string, versionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getVersion', 'artifactId', artifactId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('getVersion', 'versionId', versionId)
            const localVarPath = `/api/version/{artifactId}/version/{versionId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionApi - functional programming interface
 * @export
 */
export const VersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactVersionUploadTO} artifactVersionUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateVersion(artifactId: string, artifactVersionUploadTO: ArtifactVersionUploadTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateVersion(artifactId, artifactVersionUploadTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadVersion(artifactId: string, versionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadVersion(artifactId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllVersions(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactVersionTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllVersions(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the latest version of the requested artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestVersion(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactVersionTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestVersion(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(artifactId: string, versionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactVersionTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(artifactId, versionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VersionApi - factory interface
 * @export
 */
export const VersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionApiFp(configuration)
    return {
        /**
         * 
         * @param {string} artifactId 
         * @param {ArtifactVersionUploadTO} artifactVersionUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateVersion(artifactId: string, artifactVersionUploadTO: ArtifactVersionUploadTO, options?: any): AxiosPromise<string> {
            return localVarFp.createOrUpdateVersion(artifactId, artifactVersionUploadTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadVersion(artifactId: string, versionId: string, options?: any): AxiosPromise<any> {
            return localVarFp.downloadVersion(artifactId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVersions(artifactId: string, options?: any): AxiosPromise<Array<ArtifactVersionTO>> {
            return localVarFp.getAllVersions(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the latest version of the requested artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestVersion(artifactId: string, options?: any): AxiosPromise<ArtifactVersionTO> {
            return localVarFp.getLatestVersion(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artifactId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(artifactId: string, versionId: string, options?: any): AxiosPromise<ArtifactVersionTO> {
            return localVarFp.getVersion(artifactId, versionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export class VersionApi extends BaseAPI {
    /**
     * 
     * @param {string} artifactId 
     * @param {ArtifactVersionUploadTO} artifactVersionUploadTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public createOrUpdateVersion(artifactId: string, artifactVersionUploadTO: ArtifactVersionUploadTO, options?: any) {
        return VersionApiFp(this.configuration).createOrUpdateVersion(artifactId, artifactVersionUploadTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {string} versionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public downloadVersion(artifactId: string, versionId: string, options?: any) {
        return VersionApiFp(this.configuration).downloadVersion(artifactId, versionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public getAllVersions(artifactId: string, options?: any) {
        return VersionApiFp(this.configuration).getAllVersions(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the latest version of the requested artifact
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public getLatestVersion(artifactId: string, options?: any) {
        return VersionApiFp(this.configuration).getLatestVersion(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} artifactId 
     * @param {string} versionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public getVersion(artifactId: string, versionId: string, options?: any) {
        return VersionApiFp(this.configuration).getVersion(artifactId, versionId, options).then((request) => request(this.axios, this.basePath));
    }
}


